<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Timetable</title>
  <style>
    .icon{font-style:normal;margin-right:6px}
    :root{
      --grid-color:#e0e0e0;
      --bg:#f5f5f5;
      --primary-bg:#ffffff;
      --secondary-bg:#f8f9fa;
      --accent:#2196F3;
      --text-primary:#212529;
      --text-secondary:#6c757d;
      --border:#dee2e6;
      --recess-bg:#ADD8E6;
      --free-slot-bg:#f0fff0;
    }
    html,body{height:100%;margin:0}
    body{
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background-color: var(--bg);
      background-image:
        linear-gradient(var(--grid-color) 1px, transparent 1px),
        linear-gradient(90deg, var(--grid-color) 1px, transparent 1px);
      background-size:50px 50px,50px 50px;
      color:var(--text-primary);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      padding:20px;
      box-sizing:border-box;
    }
    .wrap{max-width:1100px;margin:0 auto;background:var(--primary-bg);padding:16px;border-radius:12px;box-shadow:0 8px 32px rgba(0,0,0,0.1)}
    h1{margin:0 0 12px;color:var(--text-primary);font-size:28px}
    #timetable{overflow:auto}
    table{border-collapse:collapse;width:100%;background:var(--secondary-bg);border-radius:8px;overflow:hidden;table-layout:fixed}
    th,td{border:1px solid var(--border);padding:10px;text-align:center;color:var(--text-primary)}
    th{background:var(--secondary-bg);font-weight:600;text-transform:uppercase;font-size:12px;letter-spacing:0.5px}
    /* Make main timetable columns equal width except first column */
    #timetable table th:first-child, #timetable table td:first-child{width:120px}
    #timetable table th:not(:first-child), #timetable table td:not(:first-child){width:auto}
    .timetable-cell.free{background:var(--free-slot-bg);color:#333}
    .controls{margin:8px 0}
    button{
      padding:10px 16px;
      font-size:14px;
      background:var(--secondary-bg);
      color:var(--text-primary);
      border:1px solid var(--border);
      border-radius:6px;
      cursor:pointer;
      transition:all 0.2s ease;
      font-weight:500;
    }
    button:hover{
      background:var(--accent);
      border-color:var(--accent);
      transform:translateY(-1px);
      box-shadow:0 4px 12px rgba(233,69,96,0.3);
    }
    /* Sidebar and modal for CRUD UI */
    .layout{display:flex;gap:16px}
    .sidebar{
      width:240px;
      padding:12px;
      border-right:1px solid var(--border);
      background:rgba(15,52,96,0.3);
      border-radius:8px;
    }
    .sidebar h2{font-size:18px;margin:0 0 12px;color:var(--accent);font-weight:600}
    .sidebar button{display:block;width:100%;margin:6px 0;text-align:left}
    .sidebar strong{color:var(--accent);font-size:14px}
    .main{flex:1}
    .modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,0.7);display:none;align-items:center;justify-content:center;backdrop-filter:blur(4px)}
    .modal{
      background:var(--primary-bg);
      border-radius:12px;
      padding:20px;
      width:720px;
      max-width:95%;
      box-shadow:0 12px 48px rgba(0,0,0,0.5);
      border:1px solid var(--border);
    }
    .tabs{display:flex;gap:8px;margin-bottom:8px}
    .tab{
      padding:8px 14px;
      border:1px solid var(--border);
      border-bottom:none;
      background:var(--secondary-bg);
      cursor:pointer;
      color:var(--text-secondary);
      border-radius:6px 6px 0 0;
      transition:all 0.2s ease;
    }
    .tab:hover{background:var(--accent);color:var(--text-primary)}
    .tab.active{background:var(--accent);border-bottom:1px solid var(--primary-bg);color:var(--text-primary);font-weight:600}
    /* Nested tabs for sub-objects */
    .nested-tabs{display:flex;gap:4px;margin:8px 0;flex-wrap:wrap}
    .nested-tab{
      padding:6px 12px;
      border:1px solid var(--border);
      background:var(--secondary-bg);
      cursor:pointer;
      color:var(--text-secondary);
      border-radius:4px;
      transition:all 0.2s ease;
      font-size:13px;
    }
    .nested-tab:hover{background:var(--accent);color:var(--text-primary)}
    .nested-tab.active{background:var(--accent);color:var(--text-primary);font-weight:600}
    .tab-content{
      border:1px solid var(--border);
      padding:12px;
      max-height:320px;
      overflow:auto;
      background:var(--primary-bg);
      border-radius:0 8px 8px 8px;
    }
    .record{display:flex;justify-content:space-between;padding:6px 10px;transition:background 0.2s ease}
    .record:hover{background:var(--secondary-bg)}
    .record .meta{flex:1;color:var(--text-primary);font-size:14px}
    .form-row{display:flex;gap:8px;align-items:center;margin:8px 0}
    .form-row label{color:var(--text-primary)}
    .form-row input,.form-row select{
      background:var(--secondary-bg);
      border:1px solid var(--border);
      color:var(--text-primary);
      padding:8px;
      border-radius:4px;
      font-size:14px;
    }
    .form-row input:focus,.form-row select:focus{
      outline:none;
      border-color:var(--accent);
      box-shadow:0 0 0 3px rgba(233,69,96,0.2);
    }
    .hidden{display:none}
    .undo-banner{
      position:fixed;
      right:16px;
      bottom:16px;
      background:var(--secondary-bg);
      color:var(--text-primary);
      padding:12px 16px;
      border-radius:8px;
      display:none;
      align-items:center;
      gap:12px;
      box-shadow:0 4px 16px rgba(0,0,0,0.2);
      border:1px solid var(--accent);
    }
    .timeslot-legend{display:flex;gap:12px;margin-top:8px;font-size:12px}
    .timeslot-legend-item{display:flex;align-items:center;gap:4px}
    .timeslot-legend-box{width:16px;height:16px;border:1px solid #999}
    /* Radio button styling */
    input[type="radio"]{
      accent-color:var(--accent);
      cursor:pointer;
    }
    label{cursor:pointer;color:var(--text-primary)}
    /* Timetable cell hover */
    .timetable-cell{cursor:pointer;transition:all 0.2s ease}
    .timetable-cell:hover{background:var(--accent);transform:scale(1.05)}
    /* Class editor modal - separate from main modal */
    .class-editor-backdrop{position:fixed;inset:0;background:rgba(0,0,0,0.5);display:none;align-items:center;justify-content:center;backdrop-filter:blur(4px);z-index:1000}
    .class-editor-modal{
      background:var(--primary-bg);
      border-radius:12px;
      padding:20px;
      width:90%;
      max-width:800px;
      max-height:85vh;
      overflow:auto;
      box-shadow:0 12px 48px rgba(0,0,0,0.2);
      border:1px solid var(--border);
    }
    /* Timeslot table in class editor */
    .timeslot-table{
      width:100%;
      border-collapse:collapse;
      margin:12px 0;
    }
    .timeslot-table th, .timeslot-table td{
      border:1px solid var(--border);
      padding:8px;
      text-align:center;
      min-width:70px;
      font-size:13px;
    }
    .timeslot-table th{
      background:var(--secondary-bg);
      font-weight:600;
    }
    .timeslot-available{
      background:#90ee90;
      color:#000;
      cursor:pointer;
    }
    .timeslot-available:hover{
      background:#7ad87a;
    }
    .timeslot-unavailable{
      background:#808080;
      color:#fff;
      cursor:not-allowed;
    }
    .timeslot-selected{
      background:#4CAF50;
      color:#fff;
      font-weight:600;
    }
    .conflict-text{
      font-size:10px;
      color:#d00;
      margin-top:4px;
    }
    /* Compact form row for class editor */
    .form-row.compact{
      display:flex;
      gap:12px;
      align-items:center;
      margin:8px 0;
    }
    .form-row.compact > *:not(label){
      flex:1;
    }
    /* Group button styling */
    .group-button{
      padding:8px 16px;
      margin:4px;
      border:2px solid var(--border);
      background:var(--secondary-bg);
      color:var(--text-secondary);
      border-radius:6px;
      cursor:pointer;
      transition:all 0.2s ease;
      font-size:14px;
      font-weight:500;
    }
    .group-button:hover{
      border-color:var(--accent);
    }
    .group-button.selected{
      background:var(--accent);
      color:#fff;
      border-color:var(--accent);
      font-weight:600;
    }
    /* Recess cells styling */
    .recess-cell{
      background:var(--recess-bg) !important;
      color:#333;
      font-weight:600;
    }
  </style>
</head>
<body>
  <div class="wrap layout">
    <aside class="sidebar">
      <h2><span class="icon">‚öôÔ∏è</span> Manage</h2>
      <button id="newClassBtn"><span class="icon">‚ûï</span> New Class</button>
      <button id="settingsBtn"><span class="icon">‚öôÔ∏è</span> Settings</button>
      <div style="margin-top:12px">
        <strong><span class="icon">üîß</span> Config</strong>
        <button id="saveConfigBtn"><span class="icon">üíæ</span> Save</button>
        <button id="restoreConfigBtn"><span class="icon">‚Ü©Ô∏è</span> Restore</button>
      </div>

    </aside>
    <main class="main">
      <h1><span class="icon">üìÖ</span> Timetable</h1>
      <div style="display:flex;gap:12px;align-items:center;margin-bottom:8px">
        <div class="tabs" id="viewModeTabs">
          <div class="tab active" data-mode="teacher"><span class="icon">üë®‚Äçüè´</span> Teachers</div>
          <div class="tab" data-mode="group"><span class="icon">üë•</span> Groups</div>
          <div class="tab" data-mode="room"><span class="icon">üö™</span> Rooms</div>
        </div>
      </div>
      <div id="topTabs" class="nested-tabs"></div>
      <div id="timetable" role="region" aria-label="Weekly timetable"></div>
    </main>
  </div>

  <!-- Modal for add/edit with tabs -->
  <div id="modalBackdrop" class="modal-backdrop" role="dialog" aria-hidden="true">
    <div class="modal" role="document">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div class="tabs" id="modalTabs"></div>
        <div><button id="closeModalBtn"><span class="icon">‚úñÔ∏è</span> Close</button></div>
      </div>
      <div id="modalContent" class="tab-content"></div>
    </div>
  </div>

  <div id="undoBanner" class="undo-banner"><span id="undoMsg"></span><button id="undoBtn"><span class="icon">‚Ü©Ô∏è</span> Undo</button></div>

  <!-- Class Editor Modal -->
  <div id="classEditorBackdrop" class="class-editor-backdrop" role="dialog" aria-hidden="true">
    <div class="class-editor-modal" role="document">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px">
        <h2 style="margin:0;color:var(--accent)"><span class="icon">üìö</span> <span id="classEditorTitle">Class Editor</span></h2>
        <button id="closeClassEditorBtn"><span class="icon">‚úñÔ∏è</span> Close</button>
      </div>
      <div id="classEditorContent"></div>
    </div>
  </div>

  <script>
    // ====== PERFORMANCE MONITORING INFRASTRUCTURE ======
    const performanceMetrics = {
      measurements: [],
      enabled: true,
      maxMeasurements: 1000 // Prevent unbounded memory growth
    };

    // Wrapper to measure function execution time
    function measurePerformance(functionName, fn) {
      if (!performanceMetrics.enabled) return fn();
      
      const startTime = performance.now();
      const result = fn();
      const endTime = performance.now();
      const duration = endTime - startTime;
      
      performanceMetrics.measurements.push({
        function: functionName,
        duration: duration,
        timestamp: Date.now()
      });
      
      // Prevent unbounded memory growth - keep only last N measurements
      if (performanceMetrics.measurements.length > performanceMetrics.maxMeasurements) {
        performanceMetrics.measurements.shift();
      }
      
      console.log(`‚è±Ô∏è ${functionName}: ${duration.toFixed(2)}ms`);
      
      return result;
    }

    // Async version for async functions
    async function measurePerformanceAsync(functionName, fn) {
      if (!performanceMetrics.enabled) return await fn();
      
      const startTime = performance.now();
      const result = await fn();
      const endTime = performance.now();
      const duration = endTime - startTime;
      
      performanceMetrics.measurements.push({
        function: functionName,
        duration: duration,
        timestamp: Date.now()
      });
      
      // Prevent unbounded memory growth - keep only last N measurements
      if (performanceMetrics.measurements.length > performanceMetrics.maxMeasurements) {
        performanceMetrics.measurements.shift();
      }
      
      console.log(`‚è±Ô∏è ${functionName}: ${duration.toFixed(2)}ms`);
      
      return result;
    }

    // Get performance summary
    function getPerformanceSummary() {
      const summary = {};
      performanceMetrics.measurements.forEach(m => {
        if (!summary[m.function]) {
          summary[m.function] = { count: 0, total: 0, min: Infinity, max: -Infinity, calls: [] };
        }
        summary[m.function].count++;
        summary[m.function].total += m.duration;
        summary[m.function].min = Math.min(summary[m.function].min, m.duration);
        summary[m.function].max = Math.max(summary[m.function].max, m.duration);
        summary[m.function].calls.push(m.duration);
      });
      
      Object.keys(summary).forEach(key => {
        summary[key].avg = summary[key].total / summary[key].count;
      });
      
      return summary;
    }

    // Log performance summary to console
    function logPerformanceSummary() {
      const summary = getPerformanceSummary();
      console.group('üìä Performance Summary');
      Object.entries(summary)
        .sort((a, b) => b[1].total - a[1].total)
        .forEach(([funcName, stats]) => {
          console.log(`${funcName}:`);
          console.log(`  Calls: ${stats.count}`);
          console.log(`  Total: ${stats.total.toFixed(2)}ms`);
          console.log(`  Avg: ${stats.avg.toFixed(2)}ms`);
          console.log(`  Min: ${stats.min.toFixed(2)}ms`);
          console.log(`  Max: ${stats.max.toFixed(2)}ms`);
        });
      console.groupEnd();
    }

    // ====== CACHING INFRASTRUCTURE ======
    const cacheStore = {
      domQueries: new Map(),
      configLookups: new Map(),
      computedValues: new Map()
    };

    // Cache DOM queries
    function getCachedElement(selector) {
      if (!cacheStore.domQueries.has(selector)) {
        cacheStore.domQueries.set(selector, document.querySelector(selector));
      }
      return cacheStore.domQueries.get(selector);
    }

    // Cache multiple DOM queries
    function getCachedElements(selector) {
      const cacheKey = `all:${selector}`;
      if (!cacheStore.domQueries.has(cacheKey)) {
        cacheStore.domQueries.set(cacheKey, Array.from(document.querySelectorAll(selector)));
      }
      return cacheStore.domQueries.get(cacheKey);
    }

    // Clear DOM cache when structure changes
    function clearDOMCache() {
      cacheStore.domQueries.clear();
    }

    // Memoize expensive computations
    function memoize(fn, keyGenerator) {
      return function(...args) {
        const key = keyGenerator ? keyGenerator(...args) : JSON.stringify(args);
        if (!cacheStore.computedValues.has(key)) {
          cacheStore.computedValues.set(key, fn(...args));
        }
        return cacheStore.computedValues.get(key);
      };
    }

    // Clear memoization cache
    function clearComputedCache() {
      cacheStore.computedValues.clear();
    }

    // ====== MAIN SETUP FUNCTION ======
    // setup will be executed when the HTML file is loaded
    function setup(){
      measurePerformance('setup', () => {
        measurePerformance('loadLastSaved', loadLastSaved);
        measurePerformance('buildAvailabilityCache', buildAvailabilityCache);
        measurePerformance('buildTimetable', buildTimetable);
        console.log('setup executed: timetable built ‚Äî master_config:', master_config);
      });
    }

    function buildTimetable(){
      return measurePerformance('buildTimetable', () => {
        // Build a slot-based timetable with time labels and recess periods
        const days = ['Mon','Tue','Wed','Thu','Fri'];
        // Define time slots with labels and types
        const timeSlots = [
          { slot: 1, label: '7:50-8:35', type: 'class' },
          { slot: 'short-recess', label: 'Short Recess\n8:35-8:45', type: 'recess' },
          { slot: 2, label: '8:45-9:30', type: 'class' },
          { slot: 3, label: '9:30-10:15', type: 'class' },
          { slot: 'long-recess', label: 'Long Recess\n10:15-10:30', type: 'recess' },
          { slot: 4, label: '10:30-11:15', type: 'class' },
          { slot: 5, label: '11:15-12:00', type: 'class' }
        ];
        
        // Create document fragment to minimize reflows (OPTIMIZATION)
        const fragment = document.createDocumentFragment();
        const table = document.createElement('table');
        const thead = document.createElement('thead');
        const headRow = document.createElement('tr');
        const emptyTh = document.createElement('th'); emptyTh.textContent='Time'; headRow.appendChild(emptyTh);
        days.forEach(d=>{const th=document.createElement('th');th.textContent=d;headRow.appendChild(th)});
        thead.appendChild(headRow); table.appendChild(thead);

        const tbody = document.createElement('tbody');
        timeSlots.forEach(timeSlot=>{
          const tr = document.createElement('tr');
          const slotCell = document.createElement('td');
          
          if(timeSlot.type === 'recess'){
            // For recess rows, only show time in first column
            const timeMatch = timeSlot.label.match(/(\d+:\d+-\d+:\d+)/);
            slotCell.textContent = timeMatch ? timeMatch[1] : timeSlot.label;
            slotCell.style.whiteSpace = 'nowrap';
            slotCell.style.fontWeight = '600';
            tr.appendChild(slotCell);
            
            // Create a merged cell spanning all 5 days with recess label
            const mergedCell = document.createElement('td');
            mergedCell.setAttribute('colspan', '5');
            mergedCell.className = 'recess-cell';
            const recessName = timeSlot.label.includes('Short') ? 'Short Recess' : 'Long Recess';
            mergedCell.textContent = recessName;
            mergedCell.style.cursor = 'default';
            tr.appendChild(mergedCell);
          } else {
            // Regular class slot
            slotCell.textContent = timeSlot.label;
            slotCell.style.whiteSpace = 'pre-line';
            slotCell.style.fontWeight = '600';
            tr.appendChild(slotCell);
            
            days.forEach((day,di)=>{
              const td = document.createElement('td');
              td.setAttribute('data-day', di); 
              td.setAttribute('data-slot', timeSlot.slot);
              td.className = 'timetable-cell';
              td.addEventListener('click', ()=> onCellClick(di, timeSlot.slot, td));
              tr.appendChild(td);
            });
          }
          tbody.appendChild(tr);
        });
        table.appendChild(tbody);
        fragment.appendChild(table);
        
        const container = document.getElementById('timetable');
        container.innerHTML = '';
        container.appendChild(fragment);
        
        // Clear DOM cache after structure changes
        clearDOMCache();
        
        // initial render for default view
        measurePerformance('renderTopTabs (from buildTimetable)', renderTopTabs);
        measurePerformance('renderTimetableForCurrentView (from buildTimetable)', renderTimetableForCurrentView);
      });
    }

    // When a cell is clicked allow assigning a class to that timeslot or editing existing class
    function onCellClick(day, slot, td){
      return measurePerformance('onCellClick', () => {
        // Check if there's already a class assigned
        const existingClassId = findClassInCell(day, slot);
        if(existingClassId){
          // Open class editor for this class
          openClassEditor(existingClassId);
        } else {
          // Open class editor for a new class (instead of assign modal)
          openClassEditor(null);
        }
      });
    }
    
    // Find class ID assigned to a specific timeslot (OPTIMIZED with cache)
    // NOTE: Returns first class if multiple exist in same slot (which indicates a conflict)
    function findClassInCell(day, slot){
      return measurePerformance('findClassInCell', () => {
        // Use availability cache for O(1) lookup instead of O(n) iteration
        const slotData = availabilityCache[day]?.[slot];
        if (slotData && slotData.classes.size > 0) {
          // Use Set iterator directly for efficiency
          return slotData.classes.values().next().value;
        }
        return null;
      });
    }

    // Undo banner helpers
    let undoTimer = null;
    function showUndoBanner(msg, undoFn, timeout=10000){
      const banner = document.getElementById('undoBanner'); const undoMsg = document.getElementById('undoMsg'); const btn = document.getElementById('undoBtn');
      undoMsg.textContent = msg; banner.style.display = 'flex';
      btn.onclick = ()=>{ try{ undoFn(); }catch(e){}; banner.style.display='none'; if(undoTimer) clearTimeout(undoTimer); };
      if(undoTimer) clearTimeout(undoTimer);
      undoTimer = setTimeout(()=>{ banner.style.display='none'; }, timeout);
    }

    // Delete with undo from modal
    function deleteRecord(key, id){
      if(!confirm('Delete this record?')) return;
      const prev = JSON.stringify(master_config);
      if(key === 'classes') removeClassFromCache(id);
      delete master_config[key][id];
      dispatchMasterConfigChanged(); renderModalContent(key);
      showUndoBanner('Deleted record', ()=>{ master_config = JSON.parse(prev); buildAvailabilityCache(); dispatchMasterConfigChanged(); renderModalContent(key); });
    }

    function exportTimetable(){
      const rows = Array.from(document.querySelectorAll('#timetable tbody tr'));
      const data = rows.map(r=>{
        const hour = r.querySelector('td').textContent;
        const cells = Array.from(r.querySelectorAll('td')).slice(1).map(td=>td.textContent.trim());
        return {hour, cells};
      });
      const blob = new Blob([JSON.stringify(data,null,2)],{type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'timetable.json'; document.body.appendChild(a); a.click(); a.remove();
      URL.revokeObjectURL(url);
    }

      // --- Persistence utilities for master_config ---
      let master_config = {};
      const INDEX_KEY = 'index';
      const LAST_QUICK_SAVE_KEY = 'last_quick_save';

      // --- Availability Cache for Performance Optimization ---
      // Cache structure: availabilityCache[day][slot] = { teachers: Set, rooms: Set, groups: Set, classes: Set }
      let availabilityCache = {};

      function initAvailabilityCache(){
        availabilityCache = {};
        for(let day = 0; day < 5; day++){
          availabilityCache[day] = {};
          for(let slot = 1; slot <= 5; slot++){
            availabilityCache[day][slot] = {
              teachers: new Set(),
              rooms: new Set(),
              groups: new Set(),
              classes: new Set()
            };
          }
        }
      }

      function buildAvailabilityCache(){
        initAvailabilityCache();
        const classes = master_config.classes || {};
        for(const classId of Object.keys(classes)){
          const cls = classes[classId];
          if(Array.isArray(cls.timeSlots)){
            for(const ts of cls.timeSlots){
              const slot = availabilityCache[ts.day]?.[ts.slot];
              if(slot){
                if(cls.teacherId) slot.teachers.add(cls.teacherId);
                if(cls.roomId) slot.rooms.add(cls.roomId);
                if(Array.isArray(cls.groupIds)){
                  cls.groupIds.forEach(gid => slot.groups.add(gid));
                }
                slot.classes.add(classId);
              }
            }
          }
        }
        console.log('Availability cache built');
      }

      function updateAvailabilityCacheForClass(classId, oldTimeSlots, newTimeSlots){
        const cls = master_config.classes[classId];
        if(!cls) return;
        
        // Remove old slots from cache
        if(Array.isArray(oldTimeSlots)){
          for(const ts of oldTimeSlots){
            const slot = availabilityCache[ts.day]?.[ts.slot];
            if(slot){
              if(cls.teacherId) slot.teachers.delete(cls.teacherId);
              if(cls.roomId) slot.rooms.delete(cls.roomId);
              if(Array.isArray(cls.groupIds)){
                cls.groupIds.forEach(gid => slot.groups.delete(gid));
              }
              slot.classes.delete(classId);
            }
          }
        }
        
        // Add new slots to cache
        if(Array.isArray(newTimeSlots)){
          for(const ts of newTimeSlots){
            const slot = availabilityCache[ts.day]?.[ts.slot];
            if(slot){
              if(cls.teacherId) slot.teachers.add(cls.teacherId);
              if(cls.roomId) slot.rooms.add(cls.roomId);
              if(Array.isArray(cls.groupIds)){
                cls.groupIds.forEach(gid => slot.groups.add(gid));
              }
              slot.classes.add(classId);
            }
          }
        }
      }

      function removeClassFromCache(classId){
        const cls = master_config.classes[classId];
        if(!cls) return;
        
        if(Array.isArray(cls.timeSlots)){
          for(const ts of cls.timeSlots){
            const slot = availabilityCache[ts.day]?.[ts.slot];
            if(slot){
              if(cls.teacherId) slot.teachers.delete(cls.teacherId);
              if(cls.roomId) slot.rooms.delete(cls.roomId);
              if(Array.isArray(cls.groupIds)){
                cls.groupIds.forEach(gid => slot.groups.delete(gid));
              }
              slot.classes.delete(classId);
            }
          }
        }
      }

      function getIndex(){
        try{
          const raw = localStorage.getItem(INDEX_KEY);
          const parsed = JSON.parse(raw);
          return Array.isArray(parsed) ? parsed : [];
        }catch(e){
          return [];
        }
      }

      function setIndex(idx){
        localStorage.setItem(INDEX_KEY, JSON.stringify(idx));
      }

      function saveMasterConfigWithTimecode(timecode){
        if(typeof master_config === 'undefined' || master_config === null) master_config = {};
        const key = `save_${timecode}`;
        localStorage.setItem(key, JSON.stringify(master_config));
        let idx = getIndex();
        idx.push({timecode: timecode, key: key, ts: Date.now()});
        if(idx.length > 5) idx = idx.slice(-5);
        setIndex(idx);
        console.log('Saved master_config under', key);
        dispatchMasterConfigChanged();
      }

      function quickSave(){
        const timecode = new Date().toISOString();
        // allow label for quick save
        const label = prompt('Quick save label (optional)');
        // save pointer for fastest load (store object with config and label)
        const quickObj = { config: master_config, label: label || ('quick '+timecode), ts: Date.now() };
        localStorage.setItem(LAST_QUICK_SAVE_KEY, JSON.stringify(quickObj));
        // also store a durable save under a timecode so it appears in the index
        const key = `save_${timecode}`;
        localStorage.setItem(key, JSON.stringify(master_config));
        let idx = getIndex();
        idx.push({timecode: timecode, key: key, ts: Date.now(), quick: true, label: quickObj.label});
        if(idx.length > 5) idx = idx.slice(-5);
        setIndex(idx);
        console.log('Quick-saved master_config at', timecode);
        dispatchMasterConfigChanged();
      }

      function autoSave(){
        // Silent save without prompting (for automatic saves on modal close)
        const timecode = new Date().toISOString();
        const label = 'auto '+timecode;
        const quickObj = { config: master_config, label: label, ts: Date.now() };
        localStorage.setItem(LAST_QUICK_SAVE_KEY, JSON.stringify(quickObj));
        // also store a durable save under a timecode so it appears in the index
        const key = `save_${timecode}`;
        localStorage.setItem(key, JSON.stringify(master_config));
        let idx = getIndex();
        idx.push({timecode: timecode, key: key, ts: Date.now(), quick: true, label: label});
        if(idx.length > 5) idx = idx.slice(-5);
        setIndex(idx);
        console.log('Auto-saved master_config at', timecode);
      }

      function ensureMasterConfigStructure(){
        if(!master_config || typeof master_config !== 'object') master_config = {};
        master_config.classes = master_config.classes || {};
        master_config.teachers = master_config.teachers || {};
        master_config.rooms = master_config.rooms || {};
        master_config.groups = master_config.groups || {};
      }

      function loadLastSaved(){
          // Prefer the last quick save if present (it may store label and config)
          const quickRaw = localStorage.getItem(LAST_QUICK_SAVE_KEY);
          if(quickRaw){
            try{ const q = JSON.parse(quickRaw); if(q && q.config) { master_config = q.config; ensureMasterConfigStructure(); console.log('Loaded master_config from last_quick_save (with label)'); return; } if(typeof q === 'object'){ master_config = q; ensureMasterConfigStructure(); console.log('Loaded master_config from last_quick_save'); return; } }catch(e){}
          }
        const idx = getIndex();
        if(idx.length === 0){ master_config = {}; ensureMasterConfigStructure(); console.log('No saved index found ‚Äî master_config initialized blank'); return; }
        const last = idx[idx.length-1];
        const raw = localStorage.getItem(last.key);
        if(raw){
          try{ master_config = JSON.parse(raw); ensureMasterConfigStructure(); console.log('Loaded master_config from', last.key); return; }catch(e){}
        }
        master_config = {};
        ensureMasterConfigStructure();
        console.log('Failed to load last save; master_config blank');
      }

      function listSaves(){
        return getIndex();
      }

      // Dispatch event when master_config changes so UI can reactively update
      function dispatchMasterConfigChanged(){
        try{ document.dispatchEvent(new CustomEvent('master_config_changed')); }catch(e){}
      }

      // Conflict detection: return array of conflict details (empty = no conflict)
      // Uses availability cache for O(1) lookups instead of O(n) iteration through all classes
      function checkConflicts(classId, candidateSlots, teacherId, roomId, groupIds){
        const conflicts = [];
        const classes = master_config.classes || {};
        
        for(const cs of candidateSlots){
          const slot = availabilityCache[cs.day]?.[cs.slot];
          if(!slot) continue;
          
          // Check teacher conflicts
          if(teacherId && slot.teachers.has(teacherId)){
            // Find which class(es) have this teacher at this time
            for(const otherId of slot.classes){
              if(otherId === classId) continue;
              const other = classes[otherId];
              if(other && other.teacherId === teacherId){
                conflicts.push({
                  type:'Teacher conflict', 
                  id: otherId, 
                  name: master_config.teachers[other.teacherId]?master_config.teachers[other.teacherId].name:other.teacherId, 
                  classId: otherId, 
                  classTitle: other.title
                });
              }
            }
          }
          
          // Check room conflicts
          if(roomId && slot.rooms.has(roomId)){
            // Find which class(es) have this room at this time
            for(const otherId of slot.classes){
              if(otherId === classId) continue;
              const other = classes[otherId];
              if(other && other.roomId === roomId){
                conflicts.push({
                  type:'Room conflict', 
                  id: otherId, 
                  name: master_config.rooms[other.roomId]?master_config.rooms[other.roomId].name:other.roomId, 
                  classId: otherId, 
                  classTitle: other.title
                });
              }
            }
          }
          
          // Check group conflicts
          if(Array.isArray(groupIds)){
            for(const g of groupIds){
              if(slot.groups.has(g)){
                // Find which class(es) have this group at this time
                for(const otherId of slot.classes){
                  if(otherId === classId) continue;
                  const other = classes[otherId];
                  if(other && Array.isArray(other.groupIds) && other.groupIds.includes(g)){
                    conflicts.push({
                      type:'Group conflict', 
                      groupId: g, 
                      groupName: master_config.groups[g]?master_config.groups[g].name:g, 
                      classId: otherId, 
                      classTitle: other.title
                    });
                  }
                }
              }
            }
          }
        }
        
        // dedupe by classId+type
        const keySet = new Set(); const dedup = [];
        conflicts.forEach(c=>{ const k = `${c.classId}|${c.type}|${c.groupId||''}`; if(!keySet.has(k)){ keySet.add(k); dedup.push(c); }});
        return dedup;
      }

      // --- Master config structure initialization ---
      // Note: structure is now initialized via ensureMasterConfigStructure() function


      // --- UI: sidebar, modal, add/edit logic ---
      function uid(prefix){ return prefix + '_' + Math.random().toString(36).slice(2,9); }

      function openModal(tabKey){
        const backdrop = document.getElementById('modalBackdrop');
        backdrop.style.display = 'flex'; backdrop.setAttribute('aria-hidden','false');
        renderModalTabs(tabKey);
        renderModalContent(tabKey);
      }

      function closeModal(){
        const backdrop = document.getElementById('modalBackdrop');
        backdrop.style.display = 'none'; backdrop.setAttribute('aria-hidden','true');
        // Refresh timetable when modal closes
        renderTimetableForCurrentView();
      }

      // Class Editor Modal Functions
      function openClassEditor(classId){
        const backdrop = document.getElementById('classEditorBackdrop');
        const content = document.getElementById('classEditorContent');
        const titleEl = document.getElementById('classEditorTitle');
        
        if(classId){
          const cls = master_config.classes[classId];
          if(!cls) return alert('Class not found');
          titleEl.textContent = cls.title || 'Edit Class';
        } else {
          titleEl.textContent = 'New Class';
        }
        
        backdrop.style.display = 'flex';
        backdrop.setAttribute('aria-hidden', 'false');
        
        renderClassEditorForm(classId);
      }
      
      function closeClassEditor(){
        const backdrop = document.getElementById('classEditorBackdrop');
        backdrop.style.display = 'none';
        backdrop.setAttribute('aria-hidden', 'true');
        renderTimetableForCurrentView();
      }
      
      function renderClassEditorForm(editId){
        const content = document.getElementById('classEditorContent');
        content.innerHTML = '';
        
        const wrapper = document.createElement('div');
        
        // Class title
        const titleRow = document.createElement('div');
        titleRow.className = 'form-row';
        titleRow.innerHTML = '<label>Title:</label>';
        const titleInput = document.createElement('input');
        titleInput.className = 'title-input';
        titleInput.style.flex = '1';
        if(editId) titleInput.value = master_config.classes[editId].title || '';
        titleRow.appendChild(titleInput);
        wrapper.appendChild(titleRow);
        
        // Compact row: Color, Teacher, Room all in one row
        const compactRow = document.createElement('div');
        compactRow.className = 'form-row compact';
        
        // Color picker
        const colorLabel = document.createElement('label');
        colorLabel.textContent = 'Color:';
        colorLabel.style.marginRight = '4px';
        compactRow.appendChild(colorLabel);
        const colorInput = document.createElement('input');
        colorInput.type = 'color';
        colorInput.className = 'color-input';
        colorInput.style.height = '40px';
        colorInput.style.cursor = 'pointer';
        colorInput.style.minWidth = '60px';
        if(editId) colorInput.value = master_config.classes[editId].color || '#4CAF50';
        else colorInput.value = '#4CAF50';
        compactRow.appendChild(colorInput);
        
        // Teacher select
        const teacherLabel = document.createElement('label');
        teacherLabel.textContent = 'Teacher:';
        teacherLabel.style.marginLeft = '12px';
        teacherLabel.style.marginRight = '4px';
        compactRow.appendChild(teacherLabel);
        const teacherSelect = document.createElement('select');
        teacherSelect.className = 'teacher-select';
        const emptyOpt = document.createElement('option');
        emptyOpt.value = '';
        emptyOpt.textContent = '(none)';
        teacherSelect.appendChild(emptyOpt);
        Object.keys(master_config.teachers).forEach(tid => {
          const o = document.createElement('option');
          o.value = tid;
          o.textContent = master_config.teachers[tid].name;
          teacherSelect.appendChild(o);
        });
        if(editId) teacherSelect.value = master_config.classes[editId].teacherId || '';
        compactRow.appendChild(teacherSelect);
        
        // Room select
        const roomLabel = document.createElement('label');
        roomLabel.textContent = 'Room:';
        roomLabel.style.marginLeft = '12px';
        roomLabel.style.marginRight = '4px';
        compactRow.appendChild(roomLabel);
        const roomSelect = document.createElement('select');
        roomSelect.className = 'room-select';
        const emptyR = document.createElement('option');
        emptyR.value = '';
        emptyR.textContent = '(none)';
        roomSelect.appendChild(emptyR);
        Object.keys(master_config.rooms).forEach(rid => {
          const o = document.createElement('option');
          o.value = rid;
          o.textContent = master_config.rooms[rid].name;
          roomSelect.appendChild(o);
        });
        if(editId) roomSelect.value = master_config.classes[editId].roomId || '';
        compactRow.appendChild(roomSelect);
        
        wrapper.appendChild(compactRow);
        
        // Groups as buttons
        const groupsRow = document.createElement('div');
        groupsRow.className = 'form-row';
        groupsRow.innerHTML = '<label style="margin-right:8px">Groups:</label>';
        const groupsWrap = document.createElement('div');
        groupsWrap.style.display = 'flex';
        groupsWrap.style.flexWrap = 'wrap';
        groupsWrap.style.gap = '4px';
        groupsWrap.style.flex = '1';
        
        Object.keys(master_config.groups).forEach(gid => {
          const groupBtn = document.createElement('button');
          groupBtn.type = 'button';
          groupBtn.className = 'group-button';
          groupBtn.setAttribute('data-group-id', gid);
          groupBtn.textContent = master_config.groups[gid].name || 'Group';
          
          if(editId && Array.isArray(master_config.classes[editId].groupIds) && master_config.classes[editId].groupIds.includes(gid)) {
            groupBtn.classList.add('selected');
          }
          
          groupBtn.addEventListener('click', (e) => {
            e.preventDefault();
            groupBtn.classList.toggle('selected');
          });
          
          groupsWrap.appendChild(groupBtn);
        });
        groupsRow.appendChild(groupsWrap);
        wrapper.appendChild(groupsRow);
        
        // Timeslot table
        const tsLabel = document.createElement('h3');
        tsLabel.textContent = 'Schedule (Click cells to assign/unassign)';
        tsLabel.style.color = 'var(--text-primary)';
        tsLabel.style.marginTop = '16px';
        wrapper.appendChild(tsLabel);
        
        const table = document.createElement('table');
        table.className = 'timeslot-table';
        
        // Header
        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');
        headerRow.innerHTML = '<th>Time</th><th>Monday</th><th>Tuesday</th><th>Wednesday</th><th>Thursday</th><th>Friday</th>';
        thead.appendChild(headerRow);
        table.appendChild(thead);
        
        // Define time slots with labels
        const timeSlots = [
          { slot: 1, label: '7:50-8:35' },
          { slot: 2, label: '8:45-9:30' },
          { slot: 3, label: '9:30-10:15' },
          { slot: 4, label: '10:30-11:15' },
          { slot: 5, label: '11:15-12:00' }
        ];
        
        // Body
        const tbody = document.createElement('tbody');
        timeSlots.forEach(timeSlot => {
          const row = document.createElement('tr');
          const slotHeader = document.createElement('th');
          slotHeader.textContent = timeSlot.label;
          row.appendChild(slotHeader);
          
          for(let day = 0; day < 5; day++){
            const cell = document.createElement('td');
            cell.setAttribute('data-day', day);
            cell.setAttribute('data-slot', timeSlot.slot);
            
            // Check if this slot is selected for this class
            const isSelected = editId && master_config.classes[editId] && master_config.classes[editId].timeSlots && 
              master_config.classes[editId].timeSlots.some(ts => ts.day === day && ts.slot === timeSlot.slot);
            
            // Get current selections for conflict checking
            const selectedTeacherId = teacherSelect.value;
            const selectedRoomId = roomSelect.value;
            const groupButtons = Array.from(wrapper.querySelectorAll('.group-button'));
            const selectedGroupIds = groupButtons.filter(btn => btn.classList.contains('selected')).map(btn => btn.getAttribute('data-group-id'));
            
            // Check for conflicts
            const conflicts = checkConflicts(editId || 'temp', [{day, slot: timeSlot.slot}], selectedTeacherId, selectedRoomId, selectedGroupIds);
            
            if(isSelected){
              cell.className = 'timeslot-selected';
              cell.innerHTML = '‚úì Assigned';
            } else if(conflicts.length > 0){
              cell.className = 'timeslot-unavailable';
              const conflictText = document.createElement('div');
              conflictText.className = 'conflict-text';
              conflictText.textContent = conflicts.map(c => c.type.replace(' conflict', '')).join(', ');
              cell.appendChild(document.createTextNode('Conflict'));
              cell.appendChild(conflictText);
            } else {
              cell.className = 'timeslot-available';
              cell.textContent = 'Available';
            }
            
            // Click handler to toggle assignment
            cell.addEventListener('click', () => {
              if(!editId) {
                alert('Please save the class first by clicking the Save Class button before assigning timeslots');
                return;
              }
              const cls = master_config.classes[editId];
              const oldTimeSlots = cls.timeSlots ? [...cls.timeSlots] : [];
              cls.timeSlots = cls.timeSlots || [];
              const idx = cls.timeSlots.findIndex(ts => ts.day === day && ts.slot === timeSlot.slot);
              if(idx >= 0){
                // Remove
                cls.timeSlots.splice(idx, 1);
              } else {
                // Add (check conflicts first)
                const currTeacher = teacherSelect.value;
                const currRoom = roomSelect.value;
                const currGroups = Array.from(wrapper.querySelectorAll('.group-button')).filter(btn => btn.classList.contains('selected')).map(btn => btn.getAttribute('data-group-id'));
                const conflicts = checkConflicts(editId, [{day, slot: timeSlot.slot}], currTeacher, currRoom, currGroups);
                if(conflicts.length > 0){
                  alert('Cannot assign: ' + conflicts.map(c => c.type + ': ' + (c.classTitle || c.name || c.groupName)).join(', '));
                  return;
                }
                cls.timeSlots.push({day, slot: timeSlot.slot});
              }
              updateAvailabilityCacheForClass(editId, oldTimeSlots, cls.timeSlots);
              dispatchMasterConfigChanged();
              renderClassEditorForm(editId); // Re-render to update table
            });
            
            row.appendChild(cell);
          }
          tbody.appendChild(row);
        });
        table.appendChild(tbody);
        wrapper.appendChild(table);
        
        // Legend
        const legend = document.createElement('div');
        legend.style.display = 'flex';
        legend.style.gap = '16px';
        legend.style.margin = '12px 0';
        legend.innerHTML = `
          <div style="display:flex;align-items:center;gap:4px">
            <div style="width:20px;height:20px;background:#90ee90;border:1px solid #000"></div>
            <span>Available</span>
          </div>
          <div style="display:flex;align-items:center;gap:4px">
            <div style="width:20px;height:20px;background:#808080;border:1px solid #000"></div>
            <span>Conflict</span>
          </div>
          <div style="display:flex;align-items:center;gap:4px">
            <div style="width:20px;height:20px;background:#4CAF50;border:1px solid #000"></div>
            <span>Assigned</span>
          </div>
        `;
        wrapper.appendChild(legend);
        
        // Save button
        const btnRow = document.createElement('div');
        btnRow.style.marginTop = '16px';
        btnRow.style.display = 'flex';
        btnRow.style.gap = '8px';
        
        const saveBtn = document.createElement('button');
        saveBtn.innerHTML = '<span class="icon">üíæ</span> Save Class';
        saveBtn.addEventListener('click', () => {
          const oldId = editId;
          saveClassFromEditor(editId, wrapper);
          // If editing existing class, refresh to show updated conflicts
          if(oldId){
            setTimeout(() => renderClassEditorForm(oldId), 100);
          }
        });
        btnRow.appendChild(saveBtn);
        
        if(editId){
          const duplicateBtn = document.createElement('button');
          duplicateBtn.innerHTML = '<span class="icon">üìã</span> Duplicate Class';
          duplicateBtn.addEventListener('click', () => {
            const cls = master_config.classes[editId];
            if(!cls) return;
            
            // Create duplicate without timeslots or groups
            const newId = uid('class');
            const newTitle = cls.title + ' (Copy)';
            
            master_config.classes[newId] = {
              title: newTitle,
              color: cls.color,
              teacherId: cls.teacherId,
              roomId: cls.roomId,
              groupIds: [], // No groups in duplicate
              timeSlots: [] // No timeslots in duplicate
            };
            
            dispatchMasterConfigChanged();
            
            // Open the new class in editor
            closeClassEditor();
            setTimeout(() => openClassEditor(newId), 100);
          });
          btnRow.appendChild(duplicateBtn);
          
          const deleteBtn = document.createElement('button');
          deleteBtn.innerHTML = '<span class="icon">üóëÔ∏è</span> Delete Class';
          deleteBtn.addEventListener('click', () => {
            if(confirm('Delete this class?')){
              removeClassFromCache(editId);
              delete master_config.classes[editId];
              dispatchMasterConfigChanged();
              closeClassEditor();
            }
          });
          btnRow.appendChild(deleteBtn);
        }
        
        wrapper.appendChild(btnRow);
        
        content.appendChild(wrapper);
      }
      
      function saveClassFromEditor(editId, wrapper){
        const title = wrapper.querySelector('.title-input').value.trim();
        if(!title) return alert('Class title required');
        
        // Check uniqueness
        const existingClass = Object.keys(master_config.classes || {}).find(i => 
          master_config.classes[i].title === title && i !== editId
        );
        if(existingClass) return alert('Class title already exists');
        
        const color = wrapper.querySelector('.color-input').value;
        const teacherId = wrapper.querySelector('.teacher-select').value || '';
        const roomId = wrapper.querySelector('.room-select').value || '';
        const groupButtons = Array.from(wrapper.querySelectorAll('.group-button'));
        const groupIds = groupButtons.filter(btn => btn.classList.contains('selected')).map(btn => btn.getAttribute('data-group-id'));
        
        const id = editId || uid('class');
        
        // Preserve existing timeslots if editing, otherwise start with empty array
        const timeSlots = editId && master_config.classes[editId] ? 
          (master_config.classes[editId].timeSlots || []) : [];
        
        // If editing, remove old class from cache (we'll re-add with updated data)
        if(editId && master_config.classes[editId]){
          removeClassFromCache(editId);
        }
        
        master_config.classes[id] = {
          title,
          color,
          teacherId,
          roomId,
          groupIds,
          timeSlots
        };
        
        // Add class to cache with current attributes
        // For both new and edited classes, add timeslots to cache
        if(timeSlots.length > 0){
          updateAvailabilityCacheForClass(id, [], timeSlots);
        }
        
        dispatchMasterConfigChanged();
        
        // If this was a new class, re-render with the new ID so timeslots can be assigned
        if(!editId){
          alert('Class created! Now you can assign timeslots.');
          renderClassEditorForm(id);
        } else {
          alert('Class saved successfully!');
        }
      }

      function renderModalTabs(activeKey){
        const tabs = [{k:'classes',n:'Classes'},{k:'teachers',n:'Teachers'},{k:'rooms',n:'Rooms'},{k:'groups',n:'Groups'}];
        const container = document.getElementById('modalTabs'); container.innerHTML = '';
        tabs.forEach(t=>{
          const btn = document.createElement('div'); btn.className = 'tab' + (t.k===activeKey? ' active':''); btn.textContent = t.n;
          btn.addEventListener('click', ()=>{ renderModalTabs(t.k); renderModalContent(t.k); });
          container.appendChild(btn);
        });
      }

      function renderModalContent(key){
        const content = document.getElementById('modalContent'); content.innerHTML = '';
        
        // Handle teachers, rooms, and groups as individual tabs now
        if(key === 'teachers' || key === 'rooms' || key === 'groups'){
          renderConfigTab(content, key);
          return;
        }
        
        // list existing records with edit buttons
        const records = master_config[key] || {};
        const list = document.createElement('div');
        
        // Sort classes alphabetically by title
        let sortedIds = Object.keys(records);
        if(key === 'classes'){
          sortedIds.sort((a, b) => {
            const titleA = (records[a].title || 'Untitled').toLowerCase();
            const titleB = (records[b].title || 'Untitled').toLowerCase();
            return titleA.localeCompare(titleB);
          });
        }
        
        sortedIds.forEach(id=>{
          const rec = records[id];
          const row = document.createElement('div'); row.className='record';
          const meta = document.createElement('div'); meta.className='meta';
            if(key==='classes') meta.textContent = (rec.title||'Untitled') + ' ‚Äî ' + (rec.class_code||'');
            else meta.textContent = rec.name || ('#'+id);
            const actions = document.createElement('div');
            const edit = document.createElement('button'); 
            const editIcon = document.createElement('span'); editIcon.className='icon'; editIcon.textContent='‚úèÔ∏è';
            edit.appendChild(editIcon); edit.appendChild(document.createTextNode(' Edit'));
            edit.addEventListener('click', ()=> openEditForm(key,id));
            const del = document.createElement('button'); 
            const delIcon = document.createElement('span'); delIcon.className='icon'; delIcon.textContent='üóëÔ∏è';
            del.appendChild(delIcon); del.appendChild(document.createTextNode(' Delete'));
            del.style.marginLeft='6px'; del.addEventListener('click', ()=> deleteRecord(key,id));
            actions.appendChild(edit); actions.appendChild(del);
          row.appendChild(meta); row.appendChild(actions); list.appendChild(row);
        });
        content.appendChild(list);

        // Don't add form for classes - only show list with edit/delete buttons
        if(key !== 'classes'){
          const form = document.createElement('div'); form.style.marginTop='8px';
          form.appendChild(renderFormForKey(key));
          content.appendChild(form);
        }

        // Listen for master_config changes to update selects/checkboxes live
        function updateLive(){
          // if classes form present, rebuild it
          const currForm = document.querySelector('#modalContent .title-input');
          if(currForm){
            // re-render the modal content to refresh selects/checkboxes while preserving any inputs if possible
            // simple approach: re-render completely
            renderModalContent(key);
          }
        }
        // remove previous listener to avoid duplicates
        document.removeEventListener('master_config_changed', updateLive);
        document.addEventListener('master_config_changed', updateLive);
      }

      function renderConfigTab(content, key){
        // Render a single config category (teachers, rooms, or groups)
        const records = master_config[key] || {};
        const list = document.createElement('div');
        Object.keys(records).forEach(id=>{
          const rec = records[id];
          const row = document.createElement('div'); row.className='record';
          const meta = document.createElement('div'); meta.className='meta';
          meta.textContent = rec.name || ('#'+id);
          const actions = document.createElement('div');
          const edit = document.createElement('button'); 
          const editIcon = document.createElement('span'); editIcon.className='icon'; editIcon.textContent='‚úèÔ∏è';
          edit.appendChild(editIcon); edit.appendChild(document.createTextNode(' Edit'));
          edit.addEventListener('click', ()=> openEditForm(key,id));
          const del = document.createElement('button'); 
          const delIcon = document.createElement('span'); delIcon.className='icon'; delIcon.textContent='üóëÔ∏è';
          del.appendChild(delIcon); del.appendChild(document.createTextNode(' Delete'));
          del.style.marginLeft='6px'; 
          del.addEventListener('click', ()=> deleteRecordWithProtection(key,id));
          actions.appendChild(edit); actions.appendChild(del);
          row.appendChild(meta); row.appendChild(actions); list.appendChild(row);
        });
        content.appendChild(list);

        // Add form for new record
        const form = document.createElement('div'); form.style.marginTop='8px';
        form.appendChild(renderFormForKey(key));
        content.appendChild(form);
      }

      function deleteRecordWithProtection(key, id){
        // Check if the record is in use by any class
        const classes = master_config.classes || {};
        const inUse = [];
        
        if(key === 'teachers'){
          Object.keys(classes).forEach(cid=>{
            if(classes[cid].teacherId === id) inUse.push(classes[cid].title || 'Untitled');
          });
          if(inUse.length > 0){
            return alert(`Cannot delete teacher. In use by classes:\n${inUse.join('\n')}`);
          }
        } else if(key === 'rooms'){
          Object.keys(classes).forEach(cid=>{
            if(classes[cid].roomId === id) inUse.push(classes[cid].title || 'Untitled');
          });
          if(inUse.length > 0){
            return alert(`Cannot delete room. In use by classes:\n${inUse.join('\n')}`);
          }
        } else if(key === 'groups'){
          Object.keys(classes).forEach(cid=>{
            if(Array.isArray(classes[cid].groupIds) && classes[cid].groupIds.includes(id)){
              inUse.push(classes[cid].title || 'Untitled');
            }
          });
          if(inUse.length > 0){
            return alert(`Cannot delete group. In use by classes:\n${inUse.join('\n')}`);
          }
        }
        
        // Proceed with deletion
        if(!confirm('Delete this record?')) return;
        const prev = JSON.stringify(master_config);
        delete master_config[key][id];
        dispatchMasterConfigChanged(); 
        renderModalContent(key);
        const undoFn = ()=>{ 
          master_config = JSON.parse(prev); 
          buildAvailabilityCache();
          dispatchMasterConfigChanged(); 
          renderModalContent(key);
        };
        showUndoBanner('Deleted record', undoFn);
      }

      function renderFormForKey(key, editId){
        const wrapper = document.createElement('div');
        const hiddenId = document.createElement('input'); hiddenId.type='hidden'; hiddenId.className='record-id';
        if(editId) hiddenId.value = editId;
        wrapper.appendChild(hiddenId);
        if(key==='teachers' || key==='rooms' || key==='groups'){
          const label = document.createElement('div'); label.textContent = (key==='teachers')? 'Teacher name:' : (key==='rooms')? 'Room name:' : 'Group name:';
          const input = document.createElement('input'); input.className='name-input'; input.style.width='60%';
          if(editId) input.value = master_config[key][editId].name || '';
          wrapper.appendChild(label); wrapper.appendChild(input);
        }
        if(key==='classes'){
          // title, teacher dropdown, room dropdown, group checkboxes
          const titleRow = document.createElement('div'); titleRow.className='form-row';
          const titleLabel = document.createElement('div'); titleLabel.textContent='Title:'; const titleInput = document.createElement('input'); titleInput.className='title-input'; titleInput.style.flex='1';
          if(editId && master_config.classes && master_config.classes[editId]) titleInput.value = master_config.classes[editId].title || '';
          titleRow.appendChild(titleLabel); titleRow.appendChild(titleInput); wrapper.appendChild(titleRow);

          const teacherRow = document.createElement('div'); teacherRow.className='form-row'; const teacherLabel = document.createElement('div'); teacherLabel.textContent='Teacher:';
          const teacherSelect = document.createElement('select'); teacherSelect.className='teacher-select';
          const emptyOpt = document.createElement('option'); emptyOpt.value=''; emptyOpt.textContent='(none)'; teacherSelect.appendChild(emptyOpt);
          Object.keys(master_config.teachers || {}).forEach(tid=>{ const o=document.createElement('option'); o.value=tid; o.textContent=master_config.teachers[tid].name; teacherSelect.appendChild(o); });
          if(editId && master_config.classes && master_config.classes[editId]) teacherSelect.value = master_config.classes[editId].teacherId || '';
          teacherRow.appendChild(teacherLabel); teacherRow.appendChild(teacherSelect); wrapper.appendChild(teacherRow);

          const roomRow = document.createElement('div'); roomRow.className='form-row'; const roomLabel = document.createElement('div'); roomLabel.textContent='Room:';
          const roomSelect = document.createElement('select'); roomSelect.className='room-select';
          const emptyR = document.createElement('option'); emptyR.value=''; emptyR.textContent='(none)'; roomSelect.appendChild(emptyR);
          Object.keys(master_config.rooms || {}).forEach(rid=>{ const o=document.createElement('option'); o.value=rid; o.textContent=master_config.rooms[rid].name; roomSelect.appendChild(o); });
          if(editId && master_config.classes && master_config.classes[editId]) roomSelect.value = master_config.classes[editId].roomId || '';
          roomRow.appendChild(roomLabel); roomRow.appendChild(roomSelect); wrapper.appendChild(roomRow);

          const groupsRow = document.createElement('div'); groupsRow.className='form-row'; const groupsLabel = document.createElement('div'); groupsLabel.textContent='Groups:';
          const groupsWrap = document.createElement('div'); groupsWrap.style.display='flex'; groupsWrap.style.flexDirection='column';
          Object.keys(master_config.groups || {}).forEach(gid=>{
            const cbRow = document.createElement('label'); cbRow.style.display='flex'; cbRow.style.alignItems='center';
            const cb = document.createElement('input'); cb.type='checkbox'; cb.value=gid; cb.className='group-checkbox';
            if(editId && master_config.classes && master_config.classes[editId] && Array.isArray(master_config.classes[editId].groupIds) && master_config.classes[editId].groupIds.includes(gid)) cb.checked=true;
            cbRow.appendChild(cb); cbRow.appendChild(document.createTextNode(' ' + (master_config.groups[gid].name||'Group')));
            groupsWrap.appendChild(cbRow);
          });
          groupsRow.appendChild(groupsLabel); groupsRow.appendChild(groupsWrap); wrapper.appendChild(groupsRow);
        }

        const btnRow = document.createElement('div'); btnRow.style.marginTop='8px';
        const addBtn = document.createElement('button'); 
        const btnIcon = document.createElement('span'); btnIcon.className='icon'; 
        btnIcon.textContent = editId? 'üíæ':'‚ûï';
        addBtn.appendChild(btnIcon); 
        addBtn.appendChild(document.createTextNode(editId? ' Save':' Add'));
        addBtn.addEventListener('click', ()=> saveFormKey(key, wrapper));
        btnRow.appendChild(addBtn);
        wrapper.appendChild(btnRow);
        return wrapper;
      }

      // Update timeslot conflict highlighting when teacher/room/group selections change
      function updateTimeslotConflictHighlighting(wrapper, editId){
        const selectedTeacherId = wrapper.querySelector('.teacher-select')?.value || '';
        const selectedRoomId = wrapper.querySelector('.room-select')?.value || '';
        const groupCheckboxes = Array.from(wrapper.querySelectorAll('.group-checkbox'));
        const selectedGroupIds = groupCheckboxes.filter(cb=>cb.checked).map(cb=>cb.value);
        
        const slotCheckboxes = wrapper.querySelectorAll('.timeslot-checkbox');
        slotCheckboxes.forEach(cb => {
          const parts = cb.value.split('_');
          const day = parseInt(parts[0], 10);
          const slot = parseInt(parts[1], 10);
          const conflicts = checkConflicts(editId || 'temp', [{day, slot}], selectedTeacherId, selectedRoomId, selectedGroupIds);
          const cellWrap = cb.parentElement;
          if(conflicts.length > 0){
            cellWrap.style.backgroundColor = '#ffcccc';
            cellWrap.title = 'Conflicts: ' + conflicts.map(c=>`${c.type} (${c.classTitle || c.name || c.groupName})`).join(', ');
          } else {
            cellWrap.style.backgroundColor = '#ccffcc';
            cellWrap.title = 'Available';
          }
        });
      }

      function openEditForm(key,id){
        // re-render tabs/content with edit form
        renderModalTabs(key);
        const content = document.getElementById('modalContent'); content.innerHTML='';
        const list = document.createElement('div');
        // show existing records (same as before)
        const records = master_config[key] || {};
        Object.keys(records).forEach(rid=>{
          const row = document.createElement('div'); row.className='record';
          const meta = document.createElement('div'); meta.className='meta';
          meta.textContent = (key==='classes')? (records[rid].title||'Untitled') : (records[rid].name||'#'+rid);
          row.appendChild(meta); list.appendChild(row);
        });
        content.appendChild(list);
        // attach edit form
        const form = renderFormForKey(key, id);
        content.appendChild(form);
      }

      function saveFormKey(key, wrapper){
        ensureMasterConfigStructure(); // Ensure structure exists before saving
        const idInput = wrapper.querySelector('.record-id'); const editId = idInput && idInput.value ? idInput.value : null;
        if(key==='teachers' || key==='rooms' || key==='groups'){
          // Ensure the key exists in master_config
          if(!master_config[key]) master_config[key] = {};
          const name = wrapper.querySelector('.name-input').value.trim(); if(!name) return alert('Name required');
          // Ensure the collection exists
          if(!master_config[key]) master_config[key] = {};
          // uniqueness check
          const existing = Object.keys(master_config[key]).find(i=> master_config[key][i].name === name && i !== editId);
          if(existing) return alert('Name already exists');
          const id = editId || uid(key);
          master_config[key][id] = { name };
          dispatchMasterConfigChanged();
        } else if(key==='classes'){
          // Ensure classes exists in master_config
          if(!master_config.classes) master_config.classes = {};
          const title = wrapper.querySelector('.title-input').value.trim();
          if(!title) return alert('Class title required');
          // Ensure the collection exists
          if(!master_config.classes) master_config.classes = {};
          // class title uniqueness
          const existingClass = Object.keys(master_config.classes).find(i=> master_config.classes[i].title === title && i !== editId);
          if(existingClass) return alert('Class title already exists');
          const teacherId = wrapper.querySelector('.teacher-select').value || '';
          const roomId = wrapper.querySelector('.room-select').value || '';
          const groupCheckboxes = Array.from(wrapper.querySelectorAll('.group-checkbox'));
          const groupIds = groupCheckboxes.filter(cb=>cb.checked).map(cb=>cb.value);
          const id = editId || uid('class');
          // prepare candidate slots from mini-timetable cells
          const timeslotCells = wrapper.querySelectorAll('.timeslot-cell');
          const candidateSlots = [];
          timeslotCells.forEach(cell=>{ 
            if(cell.dataset.selected === 'true'){ 
              candidateSlots.push({day: parseInt(cell.dataset.day,10), slot: parseInt(cell.dataset.slot,10)}); 
            }
          });
          const conflicts = checkConflicts(id, candidateSlots, teacherId, roomId, groupIds);
          if(conflicts.length){
            const msg = conflicts.map(c=> (c.type + ': ' + (c.classTitle || c.name || c.groupName))).join('\n');
            return alert('Conflict detected:\n' + msg);
          }
          master_config.classes[id] = { title, teacherId, roomId, groupIds, timeSlots: candidateSlots };
          dispatchMasterConfigChanged();
        }
        // after save, re-render modal content for the same key so lists/forms update
        renderModalContent(key);
        console.log('Saved to master_config.', key, master_config[key]);
      }

      // Hook up sidebar buttons and modal close
      document.getElementById('newClassBtn').addEventListener('click', ()=> openClassEditor(null));
      document.getElementById('settingsBtn').addEventListener('click', ()=> openModal('teachers'));
      document.getElementById('closeModalBtn').addEventListener('click', closeModal);
      document.getElementById('closeClassEditorBtn').addEventListener('click', closeClassEditor);
      document.getElementById('saveConfigBtn').addEventListener('click', ()=>{
        const timecode = new Date().toISOString();
        const label = 'save ' + timecode;
        
        // Save to last_quick_save for auto-load on next visit
        const quickObj = { config: master_config, label: label, ts: Date.now() };
        localStorage.setItem(LAST_QUICK_SAVE_KEY, JSON.stringify(quickObj));
        
        // Also save to index for restore functionality
        const key = `save_${timecode}`;
        localStorage.setItem(key, JSON.stringify(master_config));
        let idx = getIndex();
        idx.push({timecode: timecode, key: key, ts: Date.now(), label: label});
        if(idx.length > 10) idx = idx.slice(-10); // Keep last 10 saves
        setIndex(idx);
        
        alert('Configuration saved');
      });
      document.getElementById('restoreConfigBtn').addEventListener('click', ()=>{
        const idx = getIndex(); if(idx.length===0) return alert('No saves available');
        const list = idx.map((e,i)=>`${i+1}. ${e.label||e.timecode} (${new Date(e.ts).toLocaleString()})`).join('\n');
        const sel = prompt('Restore which save?\n'+list+'\nEnter number'); if(!sel) return; const n=parseInt(sel,10)-1; if(isNaN(n)||n<0||n>=idx.length) return alert('Invalid');
        const entry = idx[n]; const raw = localStorage.getItem(entry.key); if(!raw) return alert('Save not found');
        try{ const prev = JSON.stringify(master_config); master_config = JSON.parse(raw); buildAvailabilityCache(); dispatchMasterConfigChanged(); renderTimetableForCurrentView(); showUndoBanner('Restored '+(entry.label||entry.timecode), ()=>{ master_config = JSON.parse(prev); buildAvailabilityCache(); dispatchMasterConfigChanged(); renderTimetableForCurrentView(); }); }catch(e){ alert('Failed to restore'); }
      });



      // Re-populate class forms when modal opens so selects/checkboxes reflect latest master_config
      document.getElementById('modalBackdrop').addEventListener('click', (e)=>{ if(e.target.id==='modalBackdrop') closeModal(); });

      // rebuild modal tabs when master_config changes (simple approach: re-render on open)

      // View mode tabs (replacing radio buttons)
      let currentViewMode = 'teacher';
      
      document.querySelectorAll('#viewModeTabs .tab').forEach(tab => {
        tab.addEventListener('click', () => {
          // Update active state
          document.querySelectorAll('#viewModeTabs .tab').forEach(t => t.classList.remove('active'));
          tab.classList.add('active');
          
          // Update current mode
          currentViewMode = tab.getAttribute('data-mode');
          
          // Re-render
          renderTopTabs();
          renderTimetableForCurrentView();
        });
      });

      // Top tabs rendering and timetable filtering
      function renderTopTabs(){
        const container = document.getElementById('topTabs'); container.innerHTML = '';
        const mode = currentViewMode;
        let items = [];
        if(mode==='teacher') items = Object.keys(master_config.teachers||{}).map(id=>({id,name: master_config.teachers[id].name}));
        if(mode==='group') items = Object.keys(master_config.groups||{}).map(id=>({id,name: master_config.groups[id].name}));
        if(mode==='room') items = Object.keys(master_config.rooms||{}).map(id=>({id,name: master_config.rooms[id].name}));
        if(items.length===0){ container.textContent = '(no items)'; return; }
        
        // Track currently selected item
        let selectedId = items[0].id;
        
        items.forEach((it, idx) => {
          const b = document.createElement('div');
          b.className = 'nested-tab' + (idx === 0 ? ' active' : '');
          b.textContent = it.name || it.id;
          b.addEventListener('click', () => {
            // Update active state
            document.querySelectorAll('#topTabs .nested-tab').forEach(t => t.classList.remove('active'));
            b.classList.add('active');
            selectedId = it.id;
            renderTimetableFor(mode, it.id);
          });
          container.appendChild(b);
        });
        
        // Render first item by default
        if(items.length > 0){
          renderTimetableFor(mode, items[0].id);
        }
      }

      function renderTimetableForCurrentView(){
        return measurePerformance('renderTimetableForCurrentView', () => {
          const mode = currentViewMode;
          const items = (mode==='teacher'? Object.keys(master_config.teachers||{}): mode==='group'? Object.keys(master_config.groups||{}): Object.keys(master_config.rooms||{}));
          if(items.length===0) return clearTimetable();
          renderTimetableFor(mode, items[0]);
        });
      }

      function clearTimetable(){
        return measurePerformance('clearTimetable', () => {
          // OPTIMIZED: Batch DOM updates
          const cells = getCachedElements('.timetable-cell');
          cells.forEach(c=> {
            c.innerHTML = '';
            c.style.background = '';
          });
        });
      }

      function renderTimetableFor(mode, id){
        return measurePerformance('renderTimetableFor', () => {
          clearTimetable();
          const classes = master_config.classes || {};
          
          // OPTIMIZED: Query all cells once and cache
          const allCells = getCachedElements('.timetable-cell');
          
          // OPTIMIZED: Create a map for faster cell lookup by day/slot
          const cellMap = new Map();
          allCells.forEach(cell => {
            const day = cell.getAttribute('data-day');
            const slot = cell.getAttribute('data-slot');
            const key = `${day}-${slot}`;
            cellMap.set(key, cell);
          });
          
          // First, mark all cells as free
          // Note: Modern browsers batch these style changes automatically to minimize reflows
          allCells.forEach(cell => {
            cell.classList.add('free');
            cell.innerHTML = 'free';
            cell.style.background = 'white';
          });
          
          // OPTIMIZED: Pre-cache teacher/room/group names for tooltip generation
          const teacherNames = master_config.teachers || {};
          const roomNames = master_config.rooms || {};
          
          // Then fill in assigned classes
          Object.keys(classes).forEach(cid=>{
            const cls = classes[cid];
            const matches = (mode==='teacher' && cls.teacherId===id) || (mode==='room' && cls.roomId===id) || (mode==='group' && Array.isArray(cls.groupIds) && cls.groupIds.includes(id));
            if(matches && Array.isArray(cls.timeSlots)){
              cls.timeSlots.forEach(ts=>{
                const cellKey = `${ts.day}-${ts.slot}`;
                const cell = cellMap.get(cellKey);
                if(cell){
                  cell.classList.remove('free');
                  cell.innerHTML = '';
                  const div = document.createElement('div'); 
                  div.textContent = cls.title || 'Untitled'; 
                  div.title = (`${cls.title||''}\nTeacher: ${teacherNames[cls.teacherId]?teacherNames[cls.teacherId].name:'(none)'}\nRoom: ${roomNames[cls.roomId]?roomNames[cls.roomId].name:'(none)'}`);
                  cell.appendChild(div);
                  // Apply class color if available
                  if(cls.color){
                    cell.style.background = cls.color;
                  } else {
                    cell.style.background = '';
                  }
                }
              });
            }
          });
        });
      }

      // update top tabs when master_config changes
      document.addEventListener('master_config_changed', ()=>{ 
        measurePerformance('master_config_changed handler', () => {
          clearDOMCache(); // Clear cache when config changes
          clearComputedCache(); // Clear computed values cache
          renderTopTabs(); 
          renderTimetableForCurrentView(); 
        });
      });

      // ====== PERFORMANCE TESTING & SIMULATION ======
      
      // Simulate adding a class via cell click
      function simulateAddClassViaCell() {
        console.group('üß™ Simulating: Add Class via Cell Click');
        const startTime = performance.now();
        
        // Find an empty cell
        const cells = document.querySelectorAll('.timetable-cell.free');
        if (cells.length === 0) {
          console.warn('No free cells available for simulation');
          console.groupEnd();
          return;
        }
        
        const cell = cells[0];
        const day = parseInt(cell.getAttribute('data-day'));
        const slot = parseInt(cell.getAttribute('data-slot'));
        
        console.log(`Clicking cell: day=${day}, slot=${slot}`);
        cell.click();
        
        const endTime = performance.now();
        console.log(`Total time for cell click: ${(endTime - startTime).toFixed(2)}ms`);
        console.groupEnd();
      }
      
      // Simulate adding a class via modal
      function simulateAddClassViaModal() {
        console.group('üß™ Simulating: Add Class via Modal');
        const startTime = performance.now();
        
        // Create test data
        const testClassId = uid('test_class');
        const testTeacherId = uid('test_teacher');
        const testRoomId = uid('test_room');
        const testGroupId = uid('test_group');
        
        // Add teacher
        measurePerformance('Add teacher', () => {
          master_config.teachers = master_config.teachers || {};
          master_config.teachers[testTeacherId] = { name: 'Test Teacher' };
        });
        
        // Add room
        measurePerformance('Add room', () => {
          master_config.rooms = master_config.rooms || {};
          master_config.rooms[testRoomId] = { name: 'Test Room' };
        });
        
        // Add group
        measurePerformance('Add group', () => {
          master_config.groups = master_config.groups || {};
          master_config.groups[testGroupId] = { name: 'Test Group' };
        });
        
        // Add class with timeslots
        measurePerformance('Add class', () => {
          master_config.classes = master_config.classes || {};
          master_config.classes[testClassId] = {
            title: 'Test Class',
            teacherId: testTeacherId,
            roomId: testRoomId,
            groupIds: [testGroupId],
            timeSlots: [
              { day: 0, slot: 1 },
              { day: 1, slot: 2 }
            ],
            color: '#4CAF50'
          };
        });
        
        // Update cache
        measurePerformance('Update availability cache', () => {
          updateAvailabilityCacheForClass(testClassId, [], master_config.classes[testClassId].timeSlots);
        });
        
        // Trigger UI update
        measurePerformance('Trigger UI update', () => {
          dispatchMasterConfigChanged();
        });
        
        const endTime = performance.now();
        console.log(`Total time for modal add: ${(endTime - startTime).toFixed(2)}ms`);
        console.groupEnd();
        
        return testClassId;
      }
      
      // Simulate bulk operations
      function simulateBulkAddClasses(count = 10) {
        console.group(`üß™ Simulating: Bulk Add ${count} Classes`);
        const startTime = performance.now();
        
        const classIds = [];
        
        for (let i = 0; i < count; i++) {
          const classId = uid('bulk_class');
          const teacherId = uid('bulk_teacher');
          const roomId = uid('bulk_room');
          const groupId = uid('bulk_group');
          
          master_config.teachers = master_config.teachers || {};
          master_config.teachers[teacherId] = { name: `Bulk Teacher ${i}` };
          
          master_config.rooms = master_config.rooms || {};
          master_config.rooms[roomId] = { name: `Bulk Room ${i}` };
          
          master_config.groups = master_config.groups || {};
          master_config.groups[groupId] = { name: `Bulk Group ${i}` };
          
          master_config.classes = master_config.classes || {};
          master_config.classes[classId] = {
            title: `Bulk Class ${i}`,
            teacherId: teacherId,
            roomId: roomId,
            groupIds: [groupId],
            timeSlots: [
              { day: i % 5, slot: (i % 5) + 1 }
            ],
            color: `hsl(${i * 36}, 70%, 60%)`
          };
          
          updateAvailabilityCacheForClass(classId, [], master_config.classes[classId].timeSlots);
          classIds.push(classId);
        }
        
        // Single UI update at the end
        dispatchMasterConfigChanged();
        
        const endTime = performance.now();
        console.log(`Total time for bulk add ${count} classes: ${(endTime - startTime).toFixed(2)}ms`);
        console.log(`Average time per class: ${((endTime - startTime) / count).toFixed(2)}ms`);
        console.groupEnd();
        
        return classIds;
      }
      
      // Run comprehensive performance test
      function runPerformanceTest() {
        console.clear();
        console.log('%cüöÄ PERFORMANCE TEST SUITE STARTING', 'color: #4CAF50; font-size: 16px; font-weight: bold');
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        
        // Reset metrics
        performanceMetrics.measurements = [];
        
        // Test 1: Initial load
        console.group('Test 1: Initial Page Load');
        console.log('Already measured during page load - see above');
        console.groupEnd();
        
        // Test 2: Add via modal
        console.log('\n');
        const testClassId = simulateAddClassViaModal();
        
        // Test 3: Bulk operations
        console.log('\n');
        simulateBulkAddClasses(20);
        
        // Test 4: Render performance
        console.log('\n');
        console.group('Test 4: Render Performance');
        measurePerformance('Full timetable re-render', () => {
          renderTimetableForCurrentView();
        });
        console.groupEnd();
        
        // Display summary
        console.log('\n');
        console.log('%cüìä PERFORMANCE TEST SUMMARY', 'color: #2196F3; font-size: 14px; font-weight: bold');
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        logPerformanceSummary();
        
        // Analyze bottlenecks
        console.log('\n');
        console.log('%cüîç BOTTLENECK ANALYSIS', 'color: #FF9800; font-size: 14px; font-weight: bold');
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        analyzeBottlenecks();
        
        console.log('\n');
        console.log('%c‚úÖ PERFORMANCE TEST COMPLETE', 'color: #4CAF50; font-size: 16px; font-weight: bold');
      }
      
      // Analyze bottlenecks
      function analyzeBottlenecks() {
        const summary = getPerformanceSummary();
        const sortedByTotal = Object.entries(summary)
          .sort((a, b) => b[1].total - a[1].total)
          .slice(0, 5);
        
        console.log('Top 5 functions by total time:');
        sortedByTotal.forEach(([name, stats], i) => {
          console.log(`${i + 1}. ${name}: ${stats.total.toFixed(2)}ms (${stats.count} calls)`);
        });
        
        console.log('\nRecommendations:');
        sortedByTotal.forEach(([name, stats]) => {
          if (name.includes('render') && stats.avg > 10) {
            console.log(`‚ö†Ô∏è ${name} is slow (avg ${stats.avg.toFixed(2)}ms) - consider optimization`);
          }
          if (stats.count > 50) {
            console.log(`‚ö†Ô∏è ${name} is called frequently (${stats.count} times) - consider caching`);
          }
        });
        
        // Check for specific patterns
        const domOperations = Object.entries(summary).filter(([name]) => 
          name.includes('querySelector') || name.includes('DOM') || name.includes('render')
        );
        
        if (domOperations.length > 0) {
          const domTotal = domOperations.reduce((sum, [_, stats]) => sum + stats.total, 0);
          console.log(`\nüí° DOM operations total: ${domTotal.toFixed(2)}ms`);
          console.log('   Optimization: DOM operations have been optimized with caching and batch updates');
        }
      }
      
      // Make functions available globally for console access
      window.runPerformanceTest = runPerformanceTest;
      window.simulateAddClassViaCell = simulateAddClassViaCell;
      window.simulateAddClassViaModal = simulateAddClassViaModal;
      window.simulateBulkAddClasses = simulateBulkAddClasses;
      window.logPerformanceSummary = logPerformanceSummary;
      window.analyzeBottlenecks = analyzeBottlenecks;
      window.getPerformanceSummary = getPerformanceSummary;
      
      console.log('%cüéØ Performance Testing Tools Loaded', 'color: #9C27B0; font-weight: bold');
      console.log('Available commands:');
      console.log('  ‚Ä¢ runPerformanceTest() - Run comprehensive performance test');
      console.log('  ‚Ä¢ simulateAddClassViaCell() - Simulate adding class by clicking cell');
      console.log('  ‚Ä¢ simulateAddClassViaModal() - Simulate adding class via modal');
      console.log('  ‚Ä¢ simulateBulkAddClasses(n) - Add n classes at once');
      console.log('  ‚Ä¢ logPerformanceSummary() - Show performance metrics summary');
      console.log('  ‚Ä¢ analyzeBottlenecks() - Analyze performance bottlenecks');


    // run setup when loaded
    window.addEventListener('DOMContentLoaded', setup);
  </script>
</body>
</html>
