<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Timetable</title>
  <style>
    .icon{font-style:normal;margin-right:6px}
    :root{
      --grid-color:#2a2a3a;
      --bg:#1a1a2e;
      --primary-bg:#16213e;
      --secondary-bg:#0f3460;
      --accent:#e94560;
      --text-primary:#e6e6e6;
      --text-secondary:#a0a0a0;
      --border:#2d3748;
    }
    html,body{height:100%;margin:0}
    body{
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background-color: var(--bg);
      background-image:
        linear-gradient(var(--grid-color) 1px, transparent 1px),
        linear-gradient(90deg, var(--grid-color) 1px, transparent 1px);
      background-size:50px 50px,50px 50px;
      color:var(--text-primary);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      padding:20px;
      box-sizing:border-box;
    }
    .wrap{max-width:1100px;margin:0 auto;background:var(--primary-bg);padding:16px;border-radius:12px;box-shadow:0 8px 32px rgba(0,0,0,0.4)}
    h1{margin:0 0 12px;color:var(--text-primary);font-size:28px}
    #timetable{overflow:auto}
    table{border-collapse:collapse;width:100%;background:var(--secondary-bg);border-radius:8px;overflow:hidden;table-layout:fixed}
    th,td{border:1px solid var(--border);padding:10px;text-align:center;color:var(--text-primary)}
    th{background:var(--secondary-bg);font-weight:600;text-transform:uppercase;font-size:12px;letter-spacing:0.5px}
    /* Make main timetable columns equal width except first column */
    #timetable table th:first-child, #timetable table td:first-child{width:120px}
    #timetable table th:not(:first-child), #timetable table td:not(:first-child){width:auto}
    .timetable-cell.free{background:white;color:#666}
    .controls{margin:8px 0}
    button{
      padding:10px 16px;
      font-size:14px;
      background:var(--secondary-bg);
      color:var(--text-primary);
      border:1px solid var(--border);
      border-radius:6px;
      cursor:pointer;
      transition:all 0.2s ease;
      font-weight:500;
    }
    button:hover{
      background:var(--accent);
      border-color:var(--accent);
      transform:translateY(-1px);
      box-shadow:0 4px 12px rgba(233,69,96,0.3);
    }
    /* Sidebar and modal for CRUD UI */
    .layout{display:flex;gap:16px}
    .sidebar{
      width:240px;
      padding:12px;
      border-right:1px solid var(--border);
      background:rgba(15,52,96,0.3);
      border-radius:8px;
    }
    .sidebar h2{font-size:18px;margin:0 0 12px;color:var(--accent);font-weight:600}
    .sidebar button{display:block;width:100%;margin:6px 0;text-align:left}
    .sidebar strong{color:var(--accent);font-size:14px}
    .main{flex:1}
    .modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,0.7);display:none;align-items:center;justify-content:center;backdrop-filter:blur(4px)}
    .modal{
      background:var(--primary-bg);
      border-radius:12px;
      padding:20px;
      width:720px;
      max-width:95%;
      box-shadow:0 12px 48px rgba(0,0,0,0.5);
      border:1px solid var(--border);
    }
    .tabs{display:flex;gap:8px;margin-bottom:8px}
    .tab{
      padding:8px 14px;
      border:1px solid var(--border);
      border-bottom:none;
      background:var(--secondary-bg);
      cursor:pointer;
      color:var(--text-secondary);
      border-radius:6px 6px 0 0;
      transition:all 0.2s ease;
    }
    .tab:hover{background:var(--accent);color:var(--text-primary)}
    .tab.active{background:var(--accent);border-bottom:1px solid var(--primary-bg);color:var(--text-primary);font-weight:600}
    /* Nested tabs for sub-objects */
    .nested-tabs{display:flex;gap:4px;margin:8px 0;flex-wrap:wrap}
    .nested-tab{
      padding:6px 12px;
      border:1px solid var(--border);
      background:var(--secondary-bg);
      cursor:pointer;
      color:var(--text-secondary);
      border-radius:4px;
      transition:all 0.2s ease;
      font-size:13px;
    }
    .nested-tab:hover{background:var(--accent);color:var(--text-primary)}
    .nested-tab.active{background:var(--accent);color:var(--text-primary);font-weight:600}
    .tab-content{
      border:1px solid var(--border);
      padding:12px;
      max-height:320px;
      overflow:auto;
      background:var(--primary-bg);
      border-radius:0 8px 8px 8px;
    }
    .record{display:flex;justify-content:space-between;padding:10px;border-bottom:1px solid var(--border);transition:background 0.2s ease}
    .record:hover{background:var(--secondary-bg)}
    .record .meta{flex:1;color:var(--text-primary)}
    .form-row{display:flex;gap:8px;align-items:center;margin:8px 0}
    .form-row label{color:var(--text-primary)}
    .form-row input,.form-row select{
      background:var(--secondary-bg);
      border:1px solid var(--border);
      color:var(--text-primary);
      padding:8px;
      border-radius:4px;
      font-size:14px;
    }
    .form-row input:focus,.form-row select:focus{
      outline:none;
      border-color:var(--accent);
      box-shadow:0 0 0 3px rgba(233,69,96,0.2);
    }
    .hidden{display:none}
    .undo-banner{position:fixed;right:16px;bottom:16px;background:#222;color:#fff;padding:8px 12px;border-radius:6px;display:none;align-items:center;gap:8px}
    .assign-modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,0.4);display:none;align-items:center;justify-content:center}
    .assign-modal{background:#fff;padding:12px;border-radius:8px;width:320px}
    .timeslot-legend{display:flex;gap:12px;margin-top:8px;font-size:12px}
    .timeslot-legend-item{display:flex;align-items:center;gap:4px}
    .timeslot-legend-box{width:16px;height:16px;border:1px solid #999}
    .undo-banner{
      position:fixed;
      right:16px;
      bottom:16px;
      background:var(--secondary-bg);
      color:var(--text-primary);
      padding:12px 16px;
      border-radius:8px;
      display:none;
      align-items:center;
      gap:12px;
      box-shadow:0 4px 16px rgba(0,0,0,0.4);
      border:1px solid var(--accent);
    }
    .assign-modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,0.7);display:none;align-items:center;justify-content:center;backdrop-filter:blur(4px)}
    .assign-modal{
      background:var(--primary-bg);
      padding:20px;
      border-radius:12px;
      width:320px;
      box-shadow:0 12px 48px rgba(0,0,0,0.5);
      border:1px solid var(--border);
    }
    .assign-modal h3{color:var(--text-primary);margin-top:0}
    .assign-modal label{color:var(--text-primary)}
    .assign-modal select{
      background:var(--secondary-bg);
      border:1px solid var(--border);
      color:var(--text-primary);
      padding:8px;
      border-radius:4px;
      width:100%;
    }
    /* Radio button styling */
    input[type="radio"]{
      accent-color:var(--accent);
      cursor:pointer;
    }
    label{cursor:pointer;color:var(--text-primary)}
    /* Timetable cell hover */
    .timetable-cell{cursor:pointer;transition:all 0.2s ease}
    .timetable-cell:hover{background:var(--accent);transform:scale(1.05)}
    /* Class editor modal - separate from main modal */
    .class-editor-backdrop{position:fixed;inset:0;background:rgba(0,0,0,0.8);display:none;align-items:center;justify-content:center;backdrop-filter:blur(4px);z-index:1000}
    .class-editor-modal{
      background:var(--primary-bg);
      border-radius:12px;
      padding:20px;
      width:90%;
      max-width:900px;
      max-height:90vh;
      overflow:auto;
      box-shadow:0 12px 48px rgba(0,0,0,0.5);
      border:1px solid var(--border);
    }
    /* Timeslot table in class editor */
    .timeslot-table{
      width:100%;
      border-collapse:collapse;
      margin:12px 0;
    }
    .timeslot-table th, .timeslot-table td{
      border:1px solid var(--border);
      padding:12px;
      text-align:center;
      min-width:80px;
    }
    .timeslot-table th{
      background:var(--secondary-bg);
      font-weight:600;
    }
    .timeslot-available{
      background:#90ee90;
      color:#000;
      cursor:pointer;
    }
    .timeslot-available:hover{
      background:#7ad87a;
    }
    .timeslot-unavailable{
      background:#808080;
      color:#fff;
      cursor:not-allowed;
    }
    .timeslot-selected{
      background:#4CAF50;
      color:#fff;
      font-weight:600;
    }
    .conflict-text{
      font-size:10px;
      color:#d00;
      margin-top:4px;
    }
  </style>
</head>
<body>
  <div class="wrap layout">
    <aside class="sidebar">
      <h2><span class="icon">‚öôÔ∏è</span> Manage</h2>
      <button id="newClassBtn"><span class="icon">‚ûï</span> New Class</button>
      <button id="settingsBtn"><span class="icon">‚öôÔ∏è</span> Settings</button>
      <div style="margin-top:12px">
        <strong><span class="icon">üîß</span> Config</strong>
        <button id="saveConfigBtn"><span class="icon">üíæ</span> Save master_config</button>
        <button id="restoreConfigBtn"><span class="icon">‚Ü©Ô∏è</span> Restore master_config</button>
      </div>
      <div style="margin-top:12px">
        <strong><span class="icon">üìÅ</span> Saves</strong>
        <button id="quickSaveBtn"><span class="icon">‚ö°</span> Quick Save</button>
        <button id="listSavesBtn"><span class="icon">üìã</span> List Saves (console)</button>
      </div>

    </aside>
    <main class="main">
      <h1><span class="icon">üìÖ</span> Timetable</h1>
      <div style="display:flex;gap:12px;align-items:center;margin-bottom:8px">
        <div class="tabs" id="viewModeTabs">
          <div class="tab active" data-mode="teacher"><span class="icon">üë®‚Äçüè´</span> Teachers</div>
          <div class="tab" data-mode="group"><span class="icon">üë•</span> Groups</div>
          <div class="tab" data-mode="room"><span class="icon">üö™</span> Rooms</div>
        </div>
      </div>
      <div id="topTabs" class="nested-tabs"></div>
      <div class="controls">
        <button id="exportBtn"><span class="icon">‚¨áÔ∏è</span> Export JSON</button>
      </div>
      <div id="timetable" role="region" aria-label="Weekly timetable"></div>
    </main>
  </div>

  <!-- Modal for add/edit with tabs -->
  <div id="modalBackdrop" class="modal-backdrop" role="dialog" aria-hidden="true">
    <div class="modal" role="document">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div class="tabs" id="modalTabs"></div>
        <div><button id="closeModalBtn"><span class="icon">‚úñÔ∏è</span> Close</button></div>
      </div>
      <div id="modalContent" class="tab-content"></div>
    </div>
  </div>

  <!-- Assignment modal (replace prompt) -->
  <div id="assignBackdrop" class="assign-modal-backdrop" role="dialog" aria-hidden="true">
    <div class="assign-modal">
      <h3><span class="icon">‚ûï</span> Assign Class</h3>
      <div style="margin:8px 0">
        <label>Class: <select id="assignClassSelect"></select></label>
      </div>
      <div id="assignConflict" style="color:var(--accent);margin-bottom:8px"></div>
      <div style="display:flex;gap:8px;justify-content:flex-end">
        <button id="assignCancelBtn"><span class="icon">‚úñÔ∏è</span> Cancel</button>
        <button id="assignConfirmBtn"><span class="icon">‚úîÔ∏è</span> Assign</button>
      </div>
    </div>
  </div>

  <div id="undoBanner" class="undo-banner"><span id="undoMsg"></span><button id="undoBtn"><span class="icon">‚Ü©Ô∏è</span> Undo</button></div>

  <!-- Class Editor Modal -->
  <div id="classEditorBackdrop" class="class-editor-backdrop" role="dialog" aria-hidden="true">
    <div class="class-editor-modal" role="document">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px">
        <h2 style="margin:0;color:var(--accent)"><span class="icon">üìö</span> <span id="classEditorTitle">Class Editor</span></h2>
        <button id="closeClassEditorBtn"><span class="icon">‚úñÔ∏è</span> Close</button>
      </div>
      <div id="classEditorContent"></div>
    </div>
  </div>

  <script>
    // setup will be executed when the HTML file is loaded
    function setup(){
      loadLastSaved();
      buildAvailabilityCache();
      buildTimetable();
      document.getElementById('exportBtn').addEventListener('click', exportTimetable);
      console.log('setup executed: timetable built ‚Äî master_config:', master_config);
    }

    function buildTimetable(){
      // Build a slot-based timetable with time labels and recess periods
      const days = ['Mon','Tue','Wed','Thu','Fri'];
      // Define time slots with labels and types
      const timeSlots = [
        { slot: 1, label: '7:50-8:35', type: 'class' },
        { slot: 'short-recess', label: 'Short Recess\n8:35-8:45', type: 'recess' },
        { slot: 2, label: '8:45-9:30', type: 'class' },
        { slot: 3, label: '9:30-10:15', type: 'class' },
        { slot: 'long-recess', label: 'Long Recess\n10:15-10:30', type: 'recess' },
        { slot: 4, label: '10:30-11:15', type: 'class' },
        { slot: 5, label: '11:15-12:00', type: 'class' }
      ];
      const table = document.createElement('table');
      const thead = document.createElement('thead');
      const headRow = document.createElement('tr');
      const emptyTh = document.createElement('th'); emptyTh.textContent='Time'; headRow.appendChild(emptyTh);
      days.forEach(d=>{const th=document.createElement('th');th.textContent=d;headRow.appendChild(th)});
      thead.appendChild(headRow); table.appendChild(thead);

      const tbody = document.createElement('tbody');
      timeSlots.forEach(timeSlot=>{
        const tr = document.createElement('tr');
        const slotCell = document.createElement('td');
        slotCell.textContent = timeSlot.label;
        slotCell.style.whiteSpace = 'pre-line'; // Allow line breaks
        slotCell.style.fontWeight = '600';
        if(timeSlot.type === 'recess'){
          slotCell.style.background = 'var(--secondary-bg)';
        }
        tr.appendChild(slotCell);
        
        days.forEach((day,di)=>{
          const td = document.createElement('td');
          if(timeSlot.type === 'class'){
            td.setAttribute('data-day', di); 
            td.setAttribute('data-slot', timeSlot.slot);
            td.className = 'timetable-cell';
            td.addEventListener('click', ()=> onCellClick(di, timeSlot.slot, td));
          } else {
            // Recess cells - non-interactive, grey background
            td.style.background = 'var(--secondary-bg)';
            td.style.cursor = 'default';
          }
          tr.appendChild(td);
        });
        tbody.appendChild(tr);
      });
      table.appendChild(tbody);
      const container = document.getElementById('timetable');
      container.innerHTML = '';
      container.appendChild(table);
      // initial render for default view
      renderTopTabs();
      renderTimetableForCurrentView();
    }

    // When a cell is clicked allow assigning a class to that timeslot or editing existing class
    function onCellClick(day, slot, td){
      // Check if there's already a class assigned
      const existingClassId = findClassInCell(day, slot);
      if(existingClassId){
        // Open class editor for this class
        openClassEditor(existingClassId);
      } else {
        // open assignment modal (in-UI chooser)
        openAssignModal(day, slot, td);
      }
    }
    
    // Find class ID assigned to a specific timeslot
    function findClassInCell(day, slot){
      const classes = master_config.classes || {};
      for(const cid of Object.keys(classes)){
        const cls = classes[cid];
        if(Array.isArray(cls.timeSlots)){
          if(cls.timeSlots.some(ts => ts.day === day && ts.slot === slot)){
            return cid;
          }
        }
      }
      return null;
    }

    // Assignment modal logic
    let assignContext = null;
    function openAssignModal(day, slot, td){
      assignContext = {day, slot, td};
      const sel = document.getElementById('assignClassSelect'); sel.innerHTML = '';
      const classes = master_config.classes || {};
      Object.keys(classes).forEach(id=>{ const o = document.createElement('option'); o.value=id; o.textContent = classes[id].title || ('Class '+id); sel.appendChild(o); });
      document.getElementById('assignConflict').textContent = '';
      document.getElementById('assignBackdrop').style.display = 'flex'; document.getElementById('assignBackdrop').setAttribute('aria-hidden','false');
    }

    document.getElementById('assignCancelBtn').addEventListener('click', ()=>{ document.getElementById('assignBackdrop').style.display='none'; assignContext=null; });
    document.getElementById('assignConfirmBtn').addEventListener('click', ()=>{
      const sel = document.getElementById('assignClassSelect'); if(!sel.value) return alert('Select a class');
      const classId = sel.value; const cls = master_config.classes[classId]; if(!cls) return alert('Class not found');
      const candidate = {day: assignContext.day, slot: assignContext.slot};
      const conflicts = checkConflicts(classId, [candidate], cls.teacherId, cls.roomId, cls.groupIds);
      if(conflicts.length){
        document.getElementById('assignConflict').textContent = conflicts.map(c=>`${c.type}: ${c.name}`).join('; ');
        return;
      }
      const oldTimeSlots = cls.timeSlots ? [...cls.timeSlots] : [];
      cls.timeSlots = cls.timeSlots || [];
      if(!cls.timeSlots.some(ts=>ts.day===candidate.day && ts.slot===candidate.slot)) {
        cls.timeSlots.push(candidate);
        updateAvailabilityCacheForClass(classId, oldTimeSlots, cls.timeSlots);
      }
      document.getElementById('assignBackdrop').style.display='none'; assignContext=null;
      dispatchMasterConfigChanged(); renderTimetableForCurrentView();
    });

    // Undo banner helpers
    let undoTimer = null;
    function showUndoBanner(msg, undoFn, timeout=10000){
      const banner = document.getElementById('undoBanner'); const undoMsg = document.getElementById('undoMsg'); const btn = document.getElementById('undoBtn');
      undoMsg.textContent = msg; banner.style.display = 'flex';
      btn.onclick = ()=>{ try{ undoFn(); }catch(e){}; banner.style.display='none'; if(undoTimer) clearTimeout(undoTimer); };
      if(undoTimer) clearTimeout(undoTimer);
      undoTimer = setTimeout(()=>{ banner.style.display='none'; }, timeout);
    }

    // Delete with undo from modal
    function deleteRecord(key, id){
      if(!confirm('Delete this record?')) return;
      const prev = JSON.stringify(master_config);
      if(key === 'classes') removeClassFromCache(id);
      delete master_config[key][id];
      dispatchMasterConfigChanged(); renderModalContent(key);
      showUndoBanner('Deleted record', ()=>{ master_config = JSON.parse(prev); buildAvailabilityCache(); dispatchMasterConfigChanged(); renderModalContent(key); });
    }

    function exportTimetable(){
      const rows = Array.from(document.querySelectorAll('#timetable tbody tr'));
      const data = rows.map(r=>{
        const hour = r.querySelector('td').textContent;
        const cells = Array.from(r.querySelectorAll('td')).slice(1).map(td=>td.textContent.trim());
        return {hour, cells};
      });
      const blob = new Blob([JSON.stringify(data,null,2)],{type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'timetable.json'; document.body.appendChild(a); a.click(); a.remove();
      URL.revokeObjectURL(url);
    }

      // --- Persistence utilities for master_config ---
      let master_config = {};
      const INDEX_KEY = 'index';
      const LAST_QUICK_SAVE_KEY = 'last_quick_save';

      // --- Availability Cache for Performance Optimization ---
      // Cache structure: availabilityCache[day][slot] = { teachers: Set, rooms: Set, groups: Set, classes: Set }
      let availabilityCache = {};

      function initAvailabilityCache(){
        availabilityCache = {};
        for(let day = 0; day < 5; day++){
          availabilityCache[day] = {};
          for(let slot = 1; slot <= 5; slot++){
            availabilityCache[day][slot] = {
              teachers: new Set(),
              rooms: new Set(),
              groups: new Set(),
              classes: new Set()
            };
          }
        }
      }

      function buildAvailabilityCache(){
        initAvailabilityCache();
        const classes = master_config.classes || {};
        for(const classId of Object.keys(classes)){
          const cls = classes[classId];
          if(Array.isArray(cls.timeSlots)){
            for(const ts of cls.timeSlots){
              const slot = availabilityCache[ts.day]?.[ts.slot];
              if(slot){
                if(cls.teacherId) slot.teachers.add(cls.teacherId);
                if(cls.roomId) slot.rooms.add(cls.roomId);
                if(Array.isArray(cls.groupIds)){
                  cls.groupIds.forEach(gid => slot.groups.add(gid));
                }
                slot.classes.add(classId);
              }
            }
          }
        }
        console.log('Availability cache built');
      }

      function updateAvailabilityCacheForClass(classId, oldTimeSlots, newTimeSlots){
        const cls = master_config.classes[classId];
        if(!cls) return;
        
        // Remove old slots from cache
        if(Array.isArray(oldTimeSlots)){
          for(const ts of oldTimeSlots){
            const slot = availabilityCache[ts.day]?.[ts.slot];
            if(slot){
              if(cls.teacherId) slot.teachers.delete(cls.teacherId);
              if(cls.roomId) slot.rooms.delete(cls.roomId);
              if(Array.isArray(cls.groupIds)){
                cls.groupIds.forEach(gid => slot.groups.delete(gid));
              }
              slot.classes.delete(classId);
            }
          }
        }
        
        // Add new slots to cache
        if(Array.isArray(newTimeSlots)){
          for(const ts of newTimeSlots){
            const slot = availabilityCache[ts.day]?.[ts.slot];
            if(slot){
              if(cls.teacherId) slot.teachers.add(cls.teacherId);
              if(cls.roomId) slot.rooms.add(cls.roomId);
              if(Array.isArray(cls.groupIds)){
                cls.groupIds.forEach(gid => slot.groups.add(gid));
              }
              slot.classes.add(classId);
            }
          }
        }
      }

      function removeClassFromCache(classId){
        const cls = master_config.classes[classId];
        if(!cls) return;
        
        if(Array.isArray(cls.timeSlots)){
          for(const ts of cls.timeSlots){
            const slot = availabilityCache[ts.day]?.[ts.slot];
            if(slot){
              if(cls.teacherId) slot.teachers.delete(cls.teacherId);
              if(cls.roomId) slot.rooms.delete(cls.roomId);
              if(Array.isArray(cls.groupIds)){
                cls.groupIds.forEach(gid => slot.groups.delete(gid));
              }
              slot.classes.delete(classId);
            }
          }
        }
      }

      function getIndex(){
        try{
          const raw = localStorage.getItem(INDEX_KEY);
          const parsed = JSON.parse(raw);
          return Array.isArray(parsed) ? parsed : [];
        }catch(e){
          return [];
        }
      }

      function setIndex(idx){
        localStorage.setItem(INDEX_KEY, JSON.stringify(idx));
      }

      function saveMasterConfigWithTimecode(timecode){
        if(typeof master_config === 'undefined' || master_config === null) master_config = {};
        const key = `save_${timecode}`;
        localStorage.setItem(key, JSON.stringify(master_config));
        let idx = getIndex();
        idx.push({timecode: timecode, key: key, ts: Date.now()});
        if(idx.length > 5) idx = idx.slice(-5);
        setIndex(idx);
        console.log('Saved master_config under', key);
        dispatchMasterConfigChanged();
      }

      function quickSave(){
        const timecode = new Date().toISOString();
        // allow label for quick save
        const label = prompt('Quick save label (optional)');
        // save pointer for fastest load (store object with config and label)
        const quickObj = { config: master_config, label: label || ('quick '+timecode), ts: Date.now() };
        localStorage.setItem(LAST_QUICK_SAVE_KEY, JSON.stringify(quickObj));
        // also store a durable save under a timecode so it appears in the index
        const key = `save_${timecode}`;
        localStorage.setItem(key, JSON.stringify(master_config));
        let idx = getIndex();
        idx.push({timecode: timecode, key: key, ts: Date.now(), quick: true, label: quickObj.label});
        if(idx.length > 5) idx = idx.slice(-5);
        setIndex(idx);
        console.log('Quick-saved master_config at', timecode);
        dispatchMasterConfigChanged();
      }

      function autoSave(){
        // Silent save without prompting (for automatic saves on modal close)
        const timecode = new Date().toISOString();
        const label = 'auto '+timecode;
        const quickObj = { config: master_config, label: label, ts: Date.now() };
        localStorage.setItem(LAST_QUICK_SAVE_KEY, JSON.stringify(quickObj));
        // also store a durable save under a timecode so it appears in the index
        const key = `save_${timecode}`;
        localStorage.setItem(key, JSON.stringify(master_config));
        let idx = getIndex();
        idx.push({timecode: timecode, key: key, ts: Date.now(), quick: true, label: label});
        if(idx.length > 5) idx = idx.slice(-5);
        setIndex(idx);
        console.log('Auto-saved master_config at', timecode);
      }

      function ensureMasterConfigStructure(){
        if(!master_config || typeof master_config !== 'object') master_config = {};
        master_config.classes = master_config.classes || {};
        master_config.teachers = master_config.teachers || {};
        master_config.rooms = master_config.rooms || {};
        master_config.groups = master_config.groups || {};
      }

      function loadLastSaved(){
          // Prefer the last quick save if present (it may store label and config)
          const quickRaw = localStorage.getItem(LAST_QUICK_SAVE_KEY);
          if(quickRaw){
            try{ const q = JSON.parse(quickRaw); if(q && q.config) { master_config = q.config; ensureMasterConfigStructure(); console.log('Loaded master_config from last_quick_save (with label)'); return; } if(typeof q === 'object'){ master_config = q; ensureMasterConfigStructure(); console.log('Loaded master_config from last_quick_save'); return; } }catch(e){}
          }
        const idx = getIndex();
        if(idx.length === 0){ master_config = {}; ensureMasterConfigStructure(); console.log('No saved index found ‚Äî master_config initialized blank'); return; }
        const last = idx[idx.length-1];
        const raw = localStorage.getItem(last.key);
        if(raw){
          try{ master_config = JSON.parse(raw); ensureMasterConfigStructure(); console.log('Loaded master_config from', last.key); return; }catch(e){}
        }
        master_config = {};
        ensureMasterConfigStructure();
        console.log('Failed to load last save; master_config blank');
      }

      function listSaves(){
        return getIndex();
      }

      // Dispatch event when master_config changes so UI can reactively update
      function dispatchMasterConfigChanged(){
        try{ document.dispatchEvent(new CustomEvent('master_config_changed')); }catch(e){}
      }

      // Conflict detection: return array of conflict details (empty = no conflict)
      // Uses availability cache for O(1) lookups instead of O(n) iteration through all classes
      function checkConflicts(classId, candidateSlots, teacherId, roomId, groupIds){
        const conflicts = [];
        const classes = master_config.classes || {};
        
        for(const cs of candidateSlots){
          const slot = availabilityCache[cs.day]?.[cs.slot];
          if(!slot) continue;
          
          // Check teacher conflicts
          if(teacherId && slot.teachers.has(teacherId)){
            // Find which class(es) have this teacher at this time
            for(const otherId of slot.classes){
              if(otherId === classId) continue;
              const other = classes[otherId];
              if(other && other.teacherId === teacherId){
                conflicts.push({
                  type:'Teacher conflict', 
                  id: otherId, 
                  name: master_config.teachers[other.teacherId]?master_config.teachers[other.teacherId].name:other.teacherId, 
                  classId: otherId, 
                  classTitle: other.title
                });
              }
            }
          }
          
          // Check room conflicts
          if(roomId && slot.rooms.has(roomId)){
            // Find which class(es) have this room at this time
            for(const otherId of slot.classes){
              if(otherId === classId) continue;
              const other = classes[otherId];
              if(other && other.roomId === roomId){
                conflicts.push({
                  type:'Room conflict', 
                  id: otherId, 
                  name: master_config.rooms[other.roomId]?master_config.rooms[other.roomId].name:other.roomId, 
                  classId: otherId, 
                  classTitle: other.title
                });
              }
            }
          }
          
          // Check group conflicts
          if(Array.isArray(groupIds)){
            for(const g of groupIds){
              if(slot.groups.has(g)){
                // Find which class(es) have this group at this time
                for(const otherId of slot.classes){
                  if(otherId === classId) continue;
                  const other = classes[otherId];
                  if(other && Array.isArray(other.groupIds) && other.groupIds.includes(g)){
                    conflicts.push({
                      type:'Group conflict', 
                      groupId: g, 
                      groupName: master_config.groups[g]?master_config.groups[g].name:g, 
                      classId: otherId, 
                      classTitle: other.title
                    });
                  }
                }
              }
            }
          }
        }
        
        // dedupe by classId+type
        const keySet = new Set(); const dedup = [];
        conflicts.forEach(c=>{ const k = `${c.classId}|${c.type}|${c.groupId||''}`; if(!keySet.has(k)){ keySet.add(k); dedup.push(c); }});
        return dedup;
      }

      // --- Master config structure initialization ---
      // Note: structure is now initialized via ensureMasterConfigStructure() function


      // --- UI: sidebar, modal, add/edit logic ---
      function uid(prefix){ return prefix + '_' + Math.random().toString(36).slice(2,9); }

      function openModal(tabKey){
        const backdrop = document.getElementById('modalBackdrop');
        backdrop.style.display = 'flex'; backdrop.setAttribute('aria-hidden','false');
        renderModalTabs(tabKey);
        renderModalContent(tabKey);
      }

      function closeModal(){
        const backdrop = document.getElementById('modalBackdrop');
        backdrop.style.display = 'none'; backdrop.setAttribute('aria-hidden','true');
        // Refresh timetable and perform auto-save when modal closes
        renderTimetableForCurrentView();
        autoSave();
      }

      // Class Editor Modal Functions
      function openClassEditor(classId){
        const backdrop = document.getElementById('classEditorBackdrop');
        const content = document.getElementById('classEditorContent');
        const titleEl = document.getElementById('classEditorTitle');
        
        if(classId){
          const cls = master_config.classes[classId];
          if(!cls) return alert('Class not found');
          titleEl.textContent = cls.title || 'Edit Class';
        } else {
          titleEl.textContent = 'New Class';
        }
        
        backdrop.style.display = 'flex';
        backdrop.setAttribute('aria-hidden', 'false');
        
        renderClassEditorForm(classId);
      }
      
      function closeClassEditor(){
        const backdrop = document.getElementById('classEditorBackdrop');
        backdrop.style.display = 'none';
        backdrop.setAttribute('aria-hidden', 'true');
        renderTimetableForCurrentView();
        autoSave();
      }
      
      function renderClassEditorForm(editId){
        const content = document.getElementById('classEditorContent');
        content.innerHTML = '';
        
        const wrapper = document.createElement('div');
        
        // Class title
        const titleRow = document.createElement('div');
        titleRow.className = 'form-row';
        titleRow.innerHTML = '<label>Title:</label>';
        const titleInput = document.createElement('input');
        titleInput.className = 'title-input';
        titleInput.style.flex = '1';
        if(editId) titleInput.value = master_config.classes[editId].title || '';
        titleRow.appendChild(titleInput);
        wrapper.appendChild(titleRow);
        
        // Color picker
        const colorRow = document.createElement('div');
        colorRow.className = 'form-row';
        colorRow.innerHTML = '<label>Color:</label>';
        const colorInput = document.createElement('input');
        colorInput.type = 'color';
        colorInput.className = 'color-input';
        colorInput.style.flex = '1';
        colorInput.style.height = '40px';
        colorInput.style.cursor = 'pointer';
        if(editId) colorInput.value = master_config.classes[editId].color || '#4CAF50';
        else colorInput.value = '#4CAF50'; // Default green color
        colorRow.appendChild(colorInput);
        wrapper.appendChild(colorRow);
        
        // Teacher select
        const teacherRow = document.createElement('div');
        teacherRow.className = 'form-row';
        teacherRow.innerHTML = '<label>Teacher:</label>';
        const teacherSelect = document.createElement('select');
        teacherSelect.className = 'teacher-select';
        const emptyOpt = document.createElement('option');
        emptyOpt.value = '';
        emptyOpt.textContent = '(none)';
        teacherSelect.appendChild(emptyOpt);
        Object.keys(master_config.teachers).forEach(tid => {
          const o = document.createElement('option');
          o.value = tid;
          o.textContent = master_config.teachers[tid].name;
          teacherSelect.appendChild(o);
        });
        if(editId) teacherSelect.value = master_config.classes[editId].teacherId || '';
        teacherRow.appendChild(teacherSelect);
        wrapper.appendChild(teacherRow);
        
        // Room select
        const roomRow = document.createElement('div');
        roomRow.className = 'form-row';
        roomRow.innerHTML = '<label>Room:</label>';
        const roomSelect = document.createElement('select');
        roomSelect.className = 'room-select';
        const emptyR = document.createElement('option');
        emptyR.value = '';
        emptyR.textContent = '(none)';
        roomSelect.appendChild(emptyR);
        Object.keys(master_config.rooms).forEach(rid => {
          const o = document.createElement('option');
          o.value = rid;
          o.textContent = master_config.rooms[rid].name;
          roomSelect.appendChild(o);
        });
        if(editId) roomSelect.value = master_config.classes[editId].roomId || '';
        roomRow.appendChild(roomSelect);
        wrapper.appendChild(roomRow);
        
        // Groups checkboxes
        const groupsRow = document.createElement('div');
        groupsRow.className = 'form-row';
        groupsRow.innerHTML = '<label>Groups:</label>';
        const groupsWrap = document.createElement('div');
        groupsWrap.style.display = 'flex';
        groupsWrap.style.flexDirection = 'column';
        Object.keys(master_config.groups).forEach(gid => {
          const cbRow = document.createElement('label');
          cbRow.style.display = 'flex';
          cbRow.style.alignItems = 'center';
          const cb = document.createElement('input');
          cb.type = 'checkbox';
          cb.value = gid;
          cb.className = 'group-checkbox';
          if(editId && Array.isArray(master_config.classes[editId].groupIds) && master_config.classes[editId].groupIds.includes(gid)) cb.checked = true;
          cbRow.appendChild(cb);
          cbRow.appendChild(document.createTextNode(' ' + (master_config.groups[gid].name || 'Group')));
          groupsWrap.appendChild(cbRow);
        });
        groupsRow.appendChild(groupsWrap);
        wrapper.appendChild(groupsRow);
        
        // Timeslot table
        const tsLabel = document.createElement('h3');
        tsLabel.textContent = 'Schedule (Click cells to assign/unassign)';
        tsLabel.style.color = 'var(--text-primary)';
        tsLabel.style.marginTop = '16px';
        wrapper.appendChild(tsLabel);
        
        const table = document.createElement('table');
        table.className = 'timeslot-table';
        
        // Header
        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');
        headerRow.innerHTML = '<th>Time</th><th>Monday</th><th>Tuesday</th><th>Wednesday</th><th>Thursday</th><th>Friday</th>';
        thead.appendChild(headerRow);
        table.appendChild(thead);
        
        // Define time slots with labels
        const timeSlots = [
          { slot: 1, label: '7:50-8:35' },
          { slot: 2, label: '8:45-9:30' },
          { slot: 3, label: '9:30-10:15' },
          { slot: 4, label: '10:30-11:15' },
          { slot: 5, label: '11:15-12:00' }
        ];
        
        // Body
        const tbody = document.createElement('tbody');
        timeSlots.forEach(timeSlot => {
          const row = document.createElement('tr');
          const slotHeader = document.createElement('th');
          slotHeader.textContent = timeSlot.label;
          row.appendChild(slotHeader);
          
          for(let day = 0; day < 5; day++){
            const cell = document.createElement('td');
            cell.setAttribute('data-day', day);
            cell.setAttribute('data-slot', timeSlot.slot);
            
            // Check if this slot is selected for this class
            const isSelected = editId && master_config.classes[editId] && master_config.classes[editId].timeSlots && 
              master_config.classes[editId].timeSlots.some(ts => ts.day === day && ts.slot === timeSlot.slot);
            
            // Get current selections for conflict checking
            const selectedTeacherId = teacherSelect.value;
            const selectedRoomId = roomSelect.value;
            const groupCheckboxes = Array.from(wrapper.querySelectorAll('.group-checkbox'));
            const selectedGroupIds = groupCheckboxes.filter(cb => cb.checked).map(cb => cb.value);
            
            // Check for conflicts
            const conflicts = checkConflicts(editId || 'temp', [{day, slot: timeSlot.slot}], selectedTeacherId, selectedRoomId, selectedGroupIds);
            
            if(isSelected){
              cell.className = 'timeslot-selected';
              cell.innerHTML = '‚úì Assigned';
            } else if(conflicts.length > 0){
              cell.className = 'timeslot-unavailable';
              const conflictText = document.createElement('div');
              conflictText.className = 'conflict-text';
              conflictText.textContent = conflicts.map(c => c.type.replace(' conflict', '')).join(', ');
              cell.appendChild(document.createTextNode('Conflict'));
              cell.appendChild(conflictText);
            } else {
              cell.className = 'timeslot-available';
              cell.textContent = 'Available';
            }
            
            // Click handler to toggle assignment
            cell.addEventListener('click', () => {
              if(!editId) {
                alert('Please save the class first by clicking the Save Class button before assigning timeslots');
                return;
              }
              const cls = master_config.classes[editId];
              const oldTimeSlots = cls.timeSlots ? [...cls.timeSlots] : [];
              cls.timeSlots = cls.timeSlots || [];
              const idx = cls.timeSlots.findIndex(ts => ts.day === day && ts.slot === timeSlot.slot);
              if(idx >= 0){
                // Remove
                cls.timeSlots.splice(idx, 1);
              } else {
                // Add (check conflicts first)
                const currTeacher = teacherSelect.value;
                const currRoom = roomSelect.value;
                const currGroups = Array.from(wrapper.querySelectorAll('.group-checkbox')).filter(cb => cb.checked).map(cb => cb.value);
                const conflicts = checkConflicts(editId, [{day, slot: timeSlot.slot}], currTeacher, currRoom, currGroups);
                if(conflicts.length > 0){
                  alert('Cannot assign: ' + conflicts.map(c => c.type + ': ' + (c.classTitle || c.name || c.groupName)).join(', '));
                  return;
                }
                cls.timeSlots.push({day, slot: timeSlot.slot});
              }
              updateAvailabilityCacheForClass(editId, oldTimeSlots, cls.timeSlots);
              dispatchMasterConfigChanged();
              renderClassEditorForm(editId); // Re-render to update table
            });
            
            row.appendChild(cell);
          }
          tbody.appendChild(row);
        });
        table.appendChild(tbody);
        wrapper.appendChild(table);
        
        // Legend
        const legend = document.createElement('div');
        legend.style.display = 'flex';
        legend.style.gap = '16px';
        legend.style.margin = '12px 0';
        legend.innerHTML = `
          <div style="display:flex;align-items:center;gap:4px">
            <div style="width:20px;height:20px;background:#90ee90;border:1px solid #000"></div>
            <span>Available</span>
          </div>
          <div style="display:flex;align-items:center;gap:4px">
            <div style="width:20px;height:20px;background:#808080;border:1px solid #000"></div>
            <span>Conflict</span>
          </div>
          <div style="display:flex;align-items:center;gap:4px">
            <div style="width:20px;height:20px;background:#4CAF50;border:1px solid #000"></div>
            <span>Assigned</span>
          </div>
        `;
        wrapper.appendChild(legend);
        
        // Save button
        const btnRow = document.createElement('div');
        btnRow.style.marginTop = '16px';
        btnRow.style.display = 'flex';
        btnRow.style.gap = '8px';
        
        const refreshBtn = document.createElement('button');
        refreshBtn.innerHTML = '<span class="icon">üîÑ</span> Refresh Conflicts';
        refreshBtn.addEventListener('click', () => renderClassEditorForm(editId));
        btnRow.appendChild(refreshBtn);
        
        const saveBtn = document.createElement('button');
        saveBtn.innerHTML = '<span class="icon">üíæ</span> Save Class';
        saveBtn.addEventListener('click', () => saveClassFromEditor(editId, wrapper));
        btnRow.appendChild(saveBtn);
        
        if(editId){
          const deleteBtn = document.createElement('button');
          deleteBtn.innerHTML = '<span class="icon">üóëÔ∏è</span> Delete Class';
          deleteBtn.addEventListener('click', () => {
            if(confirm('Delete this class?')){
              removeClassFromCache(editId);
              delete master_config.classes[editId];
              dispatchMasterConfigChanged();
              closeClassEditor();
            }
          });
          btnRow.appendChild(deleteBtn);
        }
        
        wrapper.appendChild(btnRow);
        
        content.appendChild(wrapper);
      }
      
      function saveClassFromEditor(editId, wrapper){
        const title = wrapper.querySelector('.title-input').value.trim();
        if(!title) return alert('Class title required');
        
        // Check uniqueness
        const existingClass = Object.keys(master_config.classes || {}).find(i => 
          master_config.classes[i].title === title && i !== editId
        );
        if(existingClass) return alert('Class title already exists');
        
        const color = wrapper.querySelector('.color-input').value;
        const teacherId = wrapper.querySelector('.teacher-select').value || '';
        const roomId = wrapper.querySelector('.room-select').value || '';
        const groupCheckboxes = Array.from(wrapper.querySelectorAll('.group-checkbox'));
        const groupIds = groupCheckboxes.filter(cb => cb.checked).map(cb => cb.value);
        
        const id = editId || uid('class');
        
        // Preserve existing timeslots if editing, otherwise start with empty array
        const timeSlots = editId && master_config.classes[editId] ? 
          (master_config.classes[editId].timeSlots || []) : [];
        
        // If editing, remove old class from cache (we'll re-add with updated data)
        if(editId && master_config.classes[editId]){
          removeClassFromCache(editId);
        }
        
        master_config.classes[id] = {
          title,
          color,
          teacherId,
          roomId,
          groupIds,
          timeSlots
        };
        
        // Add class to cache with current attributes
        // For both new and edited classes, add timeslots to cache
        if(timeSlots.length > 0){
          updateAvailabilityCacheForClass(id, [], timeSlots);
        }
        
        dispatchMasterConfigChanged();
        
        // If this was a new class, re-render with the new ID so timeslots can be assigned
        if(!editId){
          alert('Class created! Now you can assign timeslots.');
          renderClassEditorForm(id);
        } else {
          alert('Class saved successfully!');
        }
      }

      function renderModalTabs(activeKey){
        const tabs = [{k:'classes',n:'Classes'},{k:'configuration',n:'Configuration'}];
        const container = document.getElementById('modalTabs'); container.innerHTML = '';
        tabs.forEach(t=>{
          const btn = document.createElement('div'); btn.className = 'tab' + (t.k===activeKey? ' active':''); btn.textContent = t.n;
          btn.addEventListener('click', ()=>{ renderModalTabs(t.k); renderModalContent(t.k); });
          container.appendChild(btn);
        });
      }

      function renderModalContent(key){
        const content = document.getElementById('modalContent'); content.innerHTML = '';
        
        if(key === 'configuration'){
          // Show teachers, rooms, and groups in separate sections
          renderConfigurationTab(content);
          return;
        }
        
        // list existing records with edit buttons
        const records = master_config[key] || {};
        const list = document.createElement('div');
        Object.keys(records).forEach(id=>{
          const rec = records[id];
          const row = document.createElement('div'); row.className='record';
          const meta = document.createElement('div'); meta.className='meta';
            if(key==='classes') meta.textContent = (rec.title||'Untitled') + ' ‚Äî ' + (rec.class_code||'');
            else meta.textContent = rec.name || ('#'+id);
            const actions = document.createElement('div');
            const edit = document.createElement('button'); 
            const editIcon = document.createElement('span'); editIcon.className='icon'; editIcon.textContent='‚úèÔ∏è';
            edit.appendChild(editIcon); edit.appendChild(document.createTextNode(' Edit'));
            edit.addEventListener('click', ()=> openEditForm(key,id));
            const del = document.createElement('button'); 
            const delIcon = document.createElement('span'); delIcon.className='icon'; delIcon.textContent='üóëÔ∏è';
            del.appendChild(delIcon); del.appendChild(document.createTextNode(' Delete'));
            del.style.marginLeft='6px'; del.addEventListener('click', ()=> deleteRecord(key,id));
            actions.appendChild(edit); actions.appendChild(del);
          row.appendChild(meta); row.appendChild(actions); list.appendChild(row);
        });
        content.appendChild(list);

        // Add form for new record
        const form = document.createElement('div'); form.style.marginTop='8px';
        form.appendChild(renderFormForKey(key));
        content.appendChild(form);

        // Listen for master_config changes to update selects/checkboxes live
        function updateLive(){
          // if classes form present, rebuild it
          const currForm = document.querySelector('#modalContent .title-input');
          if(currForm){
            // re-render the modal content to refresh selects/checkboxes while preserving any inputs if possible
            // simple approach: re-render completely
            renderModalContent(key);
          }
        }
        // remove previous listener to avoid duplicates
        document.removeEventListener('master_config_changed', updateLive);
        document.addEventListener('master_config_changed', updateLive);
      }

      function renderConfigurationTab(content){
        // Teachers section
        const teachersSection = document.createElement('div'); teachersSection.style.marginBottom='16px';
        const teachersTitle = document.createElement('h3'); teachersTitle.textContent = 'Teachers'; teachersTitle.style.fontSize='14px'; teachersTitle.style.marginBottom='8px';
        teachersSection.appendChild(teachersTitle);
        renderConfigSection(teachersSection, 'teachers');
        content.appendChild(teachersSection);

        // Rooms section
        const roomsSection = document.createElement('div'); roomsSection.style.marginBottom='16px';
        const roomsTitle = document.createElement('h3'); roomsTitle.textContent = 'Rooms'; roomsTitle.style.fontSize='14px'; roomsTitle.style.marginBottom='8px';
        roomsSection.appendChild(roomsTitle);
        renderConfigSection(roomsSection, 'rooms');
        content.appendChild(roomsSection);

        // Groups section
        const groupsSection = document.createElement('div'); groupsSection.style.marginBottom='16px';
        const groupsTitle = document.createElement('h3'); groupsTitle.textContent = 'Groups'; groupsTitle.style.fontSize='14px'; groupsTitle.style.marginBottom='8px';
        groupsSection.appendChild(groupsTitle);
        renderConfigSection(groupsSection, 'groups');
        content.appendChild(groupsSection);
      }

      function renderConfigSection(container, key){
        const records = master_config[key] || {};
        const list = document.createElement('div');
        Object.keys(records).forEach(id=>{
          const rec = records[id];
          const row = document.createElement('div'); row.className='record';
          const meta = document.createElement('div'); meta.className='meta';
          meta.textContent = rec.name || ('#'+id);
          const actions = document.createElement('div');
          const edit = document.createElement('button'); edit.textContent='Edit';
          edit.addEventListener('click', ()=> openEditFormInConfig(key,id));
          const del = document.createElement('button'); del.textContent='Delete'; del.style.marginLeft='6px'; 
          del.addEventListener('click', ()=> deleteRecordWithProtection(key,id));
          actions.appendChild(edit); actions.appendChild(del);
          row.appendChild(meta); row.appendChild(actions); list.appendChild(row);
        });
        container.appendChild(list);

        // Add form for new record
        const form = document.createElement('div'); form.style.marginTop='8px';
        form.appendChild(renderFormForKey(key));
        container.appendChild(form);
      }

      function openEditFormInConfig(key, id){
        // Re-render the configuration tab with edit form for specific item
        const content = document.getElementById('modalContent'); content.innerHTML = '';
        
        // Render all three sections but with the specific item in edit mode
        // Teachers section
        const teachersSection = document.createElement('div'); teachersSection.style.marginBottom='16px';
        const teachersTitle = document.createElement('h3'); teachersTitle.textContent = 'Teachers'; teachersTitle.style.fontSize='14px'; teachersTitle.style.marginBottom='8px';
        teachersSection.appendChild(teachersTitle);
        renderConfigSectionWithEdit(teachersSection, 'teachers', key === 'teachers' ? id : null);
        content.appendChild(teachersSection);

        // Rooms section
        const roomsSection = document.createElement('div'); roomsSection.style.marginBottom='16px';
        const roomsTitle = document.createElement('h3'); roomsTitle.textContent = 'Rooms'; roomsTitle.style.fontSize='14px'; roomsTitle.style.marginBottom='8px';
        roomsSection.appendChild(roomsTitle);
        renderConfigSectionWithEdit(roomsSection, 'rooms', key === 'rooms' ? id : null);
        content.appendChild(roomsSection);

        // Groups section
        const groupsSection = document.createElement('div'); groupsSection.style.marginBottom='16px';
        const groupsTitle = document.createElement('h3'); groupsTitle.textContent = 'Groups'; groupsTitle.style.fontSize='14px'; groupsTitle.style.marginBottom='8px';
        groupsSection.appendChild(groupsTitle);
        renderConfigSectionWithEdit(groupsSection, 'groups', key === 'groups' ? id : null);
        content.appendChild(groupsSection);
      }

      function renderConfigSectionWithEdit(container, key, editId){
        const records = master_config[key] || {};
        const list = document.createElement('div');
        Object.keys(records).forEach(id=>{
          const rec = records[id];
          const row = document.createElement('div'); row.className='record';
          const meta = document.createElement('div'); meta.className='meta';
          meta.textContent = rec.name || ('#'+id);
          row.appendChild(meta); 
          list.appendChild(row);
        });
        container.appendChild(list);

        // Add form for new/edit record
        const form = document.createElement('div'); form.style.marginTop='8px';
        form.appendChild(renderFormForKey(key, editId));
        container.appendChild(form);
      }

      function deleteRecordWithProtection(key, id){
        // Check if the record is in use by any class
        const classes = master_config.classes || {};
        const inUse = [];
        
        if(key === 'teachers'){
          Object.keys(classes).forEach(cid=>{
            if(classes[cid].teacherId === id) inUse.push(classes[cid].title || 'Untitled');
          });
          if(inUse.length > 0){
            return alert(`Cannot delete teacher. In use by classes:\n${inUse.join('\n')}`);
          }
        } else if(key === 'rooms'){
          Object.keys(classes).forEach(cid=>{
            if(classes[cid].roomId === id) inUse.push(classes[cid].title || 'Untitled');
          });
          if(inUse.length > 0){
            return alert(`Cannot delete room. In use by classes:\n${inUse.join('\n')}`);
          }
        } else if(key === 'groups'){
          Object.keys(classes).forEach(cid=>{
            if(Array.isArray(classes[cid].groupIds) && classes[cid].groupIds.includes(id)){
              inUse.push(classes[cid].title || 'Untitled');
            }
          });
          if(inUse.length > 0){
            return alert(`Cannot delete group. In use by classes:\n${inUse.join('\n')}`);
          }
        }
        
        // Proceed with deletion
        if(!confirm('Delete this record?')) return;
        const prev = JSON.stringify(master_config);
        delete master_config[key][id];
        dispatchMasterConfigChanged(); 
        const content = document.getElementById('modalContent'); content.innerHTML = '';
        renderConfigurationTab(content);
        const undoFn = ()=>{ 
          master_config = JSON.parse(prev); 
          buildAvailabilityCache();
          dispatchMasterConfigChanged(); 
          const content = document.getElementById('modalContent'); 
          content.innerHTML = ''; 
          renderConfigurationTab(content); 
        };
        showUndoBanner('Deleted record', undoFn);
      }

      function renderFormForKey(key, editId){
        const wrapper = document.createElement('div');
        const hiddenId = document.createElement('input'); hiddenId.type='hidden'; hiddenId.className='record-id';
        if(editId) hiddenId.value = editId;
        wrapper.appendChild(hiddenId);
        if(key==='teachers' || key==='rooms' || key==='groups'){
          const label = document.createElement('div'); label.textContent = (key==='teachers')? 'Teacher name:' : (key==='rooms')? 'Room name:' : 'Group name:';
          const input = document.createElement('input'); input.className='name-input'; input.style.width='60%';
          if(editId) input.value = master_config[key][editId].name || '';
          wrapper.appendChild(label); wrapper.appendChild(input);
        }
        if(key==='classes'){
          // title, teacher dropdown, room dropdown, group checkboxes
          const titleRow = document.createElement('div'); titleRow.className='form-row';
          const titleLabel = document.createElement('div'); titleLabel.textContent='Title:'; const titleInput = document.createElement('input'); titleInput.className='title-input'; titleInput.style.flex='1';
          if(editId && master_config.classes && master_config.classes[editId]) titleInput.value = master_config.classes[editId].title || '';
          titleRow.appendChild(titleLabel); titleRow.appendChild(titleInput); wrapper.appendChild(titleRow);

          const teacherRow = document.createElement('div'); teacherRow.className='form-row'; const teacherLabel = document.createElement('div'); teacherLabel.textContent='Teacher:';
          const teacherSelect = document.createElement('select'); teacherSelect.className='teacher-select';
          const emptyOpt = document.createElement('option'); emptyOpt.value=''; emptyOpt.textContent='(none)'; teacherSelect.appendChild(emptyOpt);
          Object.keys(master_config.teachers || {}).forEach(tid=>{ const o=document.createElement('option'); o.value=tid; o.textContent=master_config.teachers[tid].name; teacherSelect.appendChild(o); });
          if(editId && master_config.classes && master_config.classes[editId]) teacherSelect.value = master_config.classes[editId].teacherId || '';
          teacherRow.appendChild(teacherLabel); teacherRow.appendChild(teacherSelect); wrapper.appendChild(teacherRow);

          const roomRow = document.createElement('div'); roomRow.className='form-row'; const roomLabel = document.createElement('div'); roomLabel.textContent='Room:';
          const roomSelect = document.createElement('select'); roomSelect.className='room-select';
          const emptyR = document.createElement('option'); emptyR.value=''; emptyR.textContent='(none)'; roomSelect.appendChild(emptyR);
          Object.keys(master_config.rooms || {}).forEach(rid=>{ const o=document.createElement('option'); o.value=rid; o.textContent=master_config.rooms[rid].name; roomSelect.appendChild(o); });
          if(editId && master_config.classes && master_config.classes[editId]) roomSelect.value = master_config.classes[editId].roomId || '';
          roomRow.appendChild(roomLabel); roomRow.appendChild(roomSelect); wrapper.appendChild(roomRow);

          const groupsRow = document.createElement('div'); groupsRow.className='form-row'; const groupsLabel = document.createElement('div'); groupsLabel.textContent='Groups:';
          const groupsWrap = document.createElement('div'); groupsWrap.style.display='flex'; groupsWrap.style.flexDirection='column';
          Object.keys(master_config.groups || {}).forEach(gid=>{
            const cbRow = document.createElement('label'); cbRow.style.display='flex'; cbRow.style.alignItems='center';
            const cb = document.createElement('input'); cb.type='checkbox'; cb.value=gid; cb.className='group-checkbox';
            if(editId && master_config.classes && master_config.classes[editId] && Array.isArray(master_config.classes[editId].groupIds) && master_config.classes[editId].groupIds.includes(gid)) cb.checked=true;
            cbRow.appendChild(cb); cbRow.appendChild(document.createTextNode(' ' + (master_config.groups[gid].name||'Group')));
            groupsWrap.appendChild(cbRow);
          });
          groupsRow.appendChild(groupsLabel); groupsRow.appendChild(groupsWrap); wrapper.appendChild(groupsRow);
        }

        const btnRow = document.createElement('div'); btnRow.style.marginTop='8px';
        const addBtn = document.createElement('button'); 
        const btnIcon = document.createElement('span'); btnIcon.className='icon'; 
        btnIcon.textContent = editId? 'üíæ':'‚ûï';
        addBtn.appendChild(btnIcon); 
        addBtn.appendChild(document.createTextNode(editId? ' Save':' Add'));
        addBtn.addEventListener('click', ()=> saveFormKey(key, wrapper));
        btnRow.appendChild(addBtn);
        wrapper.appendChild(btnRow);
        return wrapper;
      }

      // Update timeslot conflict highlighting when teacher/room/group selections change
      function updateTimeslotConflictHighlighting(wrapper, editId){
        const selectedTeacherId = wrapper.querySelector('.teacher-select')?.value || '';
        const selectedRoomId = wrapper.querySelector('.room-select')?.value || '';
        const groupCheckboxes = Array.from(wrapper.querySelectorAll('.group-checkbox'));
        const selectedGroupIds = groupCheckboxes.filter(cb=>cb.checked).map(cb=>cb.value);
        
        const slotCheckboxes = wrapper.querySelectorAll('.timeslot-checkbox');
        slotCheckboxes.forEach(cb => {
          const parts = cb.value.split('_');
          const day = parseInt(parts[0], 10);
          const slot = parseInt(parts[1], 10);
          const conflicts = checkConflicts(editId || 'temp', [{day, slot}], selectedTeacherId, selectedRoomId, selectedGroupIds);
          const cellWrap = cb.parentElement;
          if(conflicts.length > 0){
            cellWrap.style.backgroundColor = '#ffcccc';
            cellWrap.title = 'Conflicts: ' + conflicts.map(c=>`${c.type} (${c.classTitle || c.name || c.groupName})`).join(', ');
          } else {
            cellWrap.style.backgroundColor = '#ccffcc';
            cellWrap.title = 'Available';
          }
        });
      }

      function openEditForm(key,id){
        // re-render tabs/content with edit form
        renderModalTabs(key);
        const content = document.getElementById('modalContent'); content.innerHTML='';
        const list = document.createElement('div');
        // show existing records (same as before)
        const records = master_config[key] || {};
        Object.keys(records).forEach(rid=>{
          const row = document.createElement('div'); row.className='record';
          const meta = document.createElement('div'); meta.className='meta';
          meta.textContent = (key==='classes')? (records[rid].title||'Untitled') : (records[rid].name||'#'+rid);
          row.appendChild(meta); list.appendChild(row);
        });
        content.appendChild(list);
        // attach edit form
        const form = renderFormForKey(key, id);
        content.appendChild(form);
      }

      function saveFormKey(key, wrapper){
        ensureMasterConfigStructure(); // Ensure structure exists before saving
        const idInput = wrapper.querySelector('.record-id'); const editId = idInput && idInput.value ? idInput.value : null;
        if(key==='teachers' || key==='rooms' || key==='groups'){
          // Ensure the key exists in master_config
          if(!master_config[key]) master_config[key] = {};
          const name = wrapper.querySelector('.name-input').value.trim(); if(!name) return alert('Name required');
          // Ensure the collection exists
          if(!master_config[key]) master_config[key] = {};
          // uniqueness check
          const existing = Object.keys(master_config[key]).find(i=> master_config[key][i].name === name && i !== editId);
          if(existing) return alert('Name already exists');
          const id = editId || uid(key);
          master_config[key][id] = { name };
          dispatchMasterConfigChanged();
        } else if(key==='classes'){
          // Ensure classes exists in master_config
          if(!master_config.classes) master_config.classes = {};
          const title = wrapper.querySelector('.title-input').value.trim();
          if(!title) return alert('Class title required');
          // Ensure the collection exists
          if(!master_config.classes) master_config.classes = {};
          // class title uniqueness
          const existingClass = Object.keys(master_config.classes).find(i=> master_config.classes[i].title === title && i !== editId);
          if(existingClass) return alert('Class title already exists');
          const teacherId = wrapper.querySelector('.teacher-select').value || '';
          const roomId = wrapper.querySelector('.room-select').value || '';
          const groupCheckboxes = Array.from(wrapper.querySelectorAll('.group-checkbox'));
          const groupIds = groupCheckboxes.filter(cb=>cb.checked).map(cb=>cb.value);
          const id = editId || uid('class');
          // prepare candidate slots from mini-timetable cells
          const timeslotCells = wrapper.querySelectorAll('.timeslot-cell');
          const candidateSlots = [];
          timeslotCells.forEach(cell=>{ 
            if(cell.dataset.selected === 'true'){ 
              candidateSlots.push({day: parseInt(cell.dataset.day,10), slot: parseInt(cell.dataset.slot,10)}); 
            }
          });
          const conflicts = checkConflicts(id, candidateSlots, teacherId, roomId, groupIds);
          if(conflicts.length){
            const msg = conflicts.map(c=> (c.type + ': ' + (c.classTitle || c.name || c.groupName))).join('\n');
            return alert('Conflict detected:\n' + msg);
          }
          master_config.classes[id] = { title, teacherId, roomId, groupIds, timeSlots: candidateSlots };
          dispatchMasterConfigChanged();
        }
        // after save, re-render modal content for the same key so lists/forms update
        if(key==='teachers' || key==='rooms' || key==='groups'){
          // If we're in configuration tab, re-render the configuration tab
          const content = document.getElementById('modalContent'); 
          content.innerHTML = '';
          renderConfigurationTab(content);
        } else {
          renderModalContent(key);
        }
        console.log('Saved to master_config.', key, master_config[key]);
      }

      // Hook up sidebar buttons and modal close
      document.getElementById('newClassBtn').addEventListener('click', ()=> openClassEditor(null));
      document.getElementById('settingsBtn').addEventListener('click', ()=> openModal('configuration'));
      document.getElementById('closeModalBtn').addEventListener('click', closeModal);
      document.getElementById('closeClassEditorBtn').addEventListener('click', closeClassEditor);
      document.getElementById('quickSaveBtn').addEventListener('click', ()=>{ quickSave(); alert('Quick saved'); });
      document.getElementById('listSavesBtn').addEventListener('click', ()=>{ console.log('Saves index:', listSaves()); alert('Saves logged to console'); });
      document.getElementById('saveConfigBtn').addEventListener('click', ()=>{
        const label = prompt('Save label (optional)');
        const timecode = new Date().toISOString();
        saveMasterConfigWithTimecode(timecode);
        // store label in index entry
        const idx = getIndex(); if(idx.length){ idx[idx.length-1].label = label || ('save '+timecode); setIndex(idx); }
        alert('Saved master_config');
      });
      document.getElementById('restoreConfigBtn').addEventListener('click', ()=>{
        const idx = getIndex(); if(idx.length===0) return alert('No saves available');
        const list = idx.map((e,i)=>`${i+1}. ${e.label||e.timecode} (${new Date(e.ts).toLocaleString()})`).join('\n');
        const sel = prompt('Restore which save?\n'+list+'\nEnter number'); if(!sel) return; const n=parseInt(sel,10)-1; if(isNaN(n)||n<0||n>=idx.length) return alert('Invalid');
        const entry = idx[n]; const raw = localStorage.getItem(entry.key); if(!raw) return alert('Save not found');
        try{ const prev = JSON.stringify(master_config); master_config = JSON.parse(raw); buildAvailabilityCache(); dispatchMasterConfigChanged(); renderTimetableForCurrentView(); showUndoBanner('Restored '+(entry.label||entry.timecode), ()=>{ master_config = JSON.parse(prev); buildAvailabilityCache(); dispatchMasterConfigChanged(); renderTimetableForCurrentView(); }); }catch(e){ alert('Failed to restore'); }
      });



      // Re-populate class forms when modal opens so selects/checkboxes reflect latest master_config
      document.getElementById('modalBackdrop').addEventListener('click', (e)=>{ if(e.target.id==='modalBackdrop') closeModal(); });

      // rebuild modal tabs when master_config changes (simple approach: re-render on open)

      // View mode tabs (replacing radio buttons)
      let currentViewMode = 'teacher';
      
      document.querySelectorAll('#viewModeTabs .tab').forEach(tab => {
        tab.addEventListener('click', () => {
          // Update active state
          document.querySelectorAll('#viewModeTabs .tab').forEach(t => t.classList.remove('active'));
          tab.classList.add('active');
          
          // Update current mode
          currentViewMode = tab.getAttribute('data-mode');
          
          // Re-render
          renderTopTabs();
          renderTimetableForCurrentView();
        });
      });

      // Top tabs rendering and timetable filtering
      function renderTopTabs(){
        const container = document.getElementById('topTabs'); container.innerHTML = '';
        const mode = currentViewMode;
        let items = [];
        if(mode==='teacher') items = Object.keys(master_config.teachers||{}).map(id=>({id,name: master_config.teachers[id].name}));
        if(mode==='group') items = Object.keys(master_config.groups||{}).map(id=>({id,name: master_config.groups[id].name}));
        if(mode==='room') items = Object.keys(master_config.rooms||{}).map(id=>({id,name: master_config.rooms[id].name}));
        if(items.length===0){ container.textContent = '(no items)'; return; }
        
        // Track currently selected item
        let selectedId = items[0].id;
        
        items.forEach((it, idx) => {
          const b = document.createElement('div');
          b.className = 'nested-tab' + (idx === 0 ? ' active' : '');
          b.textContent = it.name || it.id;
          b.addEventListener('click', () => {
            // Update active state
            document.querySelectorAll('#topTabs .nested-tab').forEach(t => t.classList.remove('active'));
            b.classList.add('active');
            selectedId = it.id;
            renderTimetableFor(mode, it.id);
          });
          container.appendChild(b);
        });
        
        // Render first item by default
        if(items.length > 0){
          renderTimetableFor(mode, items[0].id);
        }
      }

      function renderTimetableForCurrentView(){
        const mode = currentViewMode;
        const items = (mode==='teacher'? Object.keys(master_config.teachers||{}): mode==='group'? Object.keys(master_config.groups||{}): Object.keys(master_config.rooms||{}));
        if(items.length===0) return clearTimetable();
        renderTimetableFor(mode, items[0]);
      }

      function clearTimetable(){
        document.querySelectorAll('.timetable-cell').forEach(c=> {
          c.innerHTML = '';
          c.style.background = '';
        });
      }

      function renderTimetableFor(mode, id){
        clearTimetable();
        const classes = master_config.classes || {};
        
        // First, mark all cells as free
        document.querySelectorAll('.timetable-cell').forEach(cell => {
          cell.classList.add('free');
          cell.innerHTML = 'free';
          cell.style.background = 'white';
        });
        
        // Then fill in assigned classes
        Object.keys(classes).forEach(cid=>{
          const cls = classes[cid];
          const matches = (mode==='teacher' && cls.teacherId===id) || (mode==='room' && cls.roomId===id) || (mode==='group' && Array.isArray(cls.groupIds) && cls.groupIds.includes(id));
          if(matches && Array.isArray(cls.timeSlots)){
            cls.timeSlots.forEach(ts=>{
              const selector = `.timetable-cell[data-day="${ts.day}"][data-slot="${ts.slot}"]`;
              const cell = document.querySelector(selector);
              if(cell){
                cell.classList.remove('free');
                cell.innerHTML = '';
                const div = document.createElement('div'); 
                div.textContent = cls.title || 'Untitled'; 
                div.title = (`${cls.title||''}\nTeacher: ${master_config.teachers[cls.teacherId]?master_config.teachers[cls.teacherId].name:'(none)'}\nRoom: ${master_config.rooms[cls.roomId]?master_config.rooms[cls.roomId].name:'(none)'}`);
                cell.appendChild(div);
                // Apply class color if available
                if(cls.color){
                  cell.style.background = cls.color;
                } else {
                  cell.style.background = '';
                }
              }
            });
          }
        });
      }

      // update top tabs when master_config changes
      document.addEventListener('master_config_changed', ()=>{ renderTopTabs(); renderTimetableForCurrentView(); });


    // run setup when loaded
    window.addEventListener('DOMContentLoaded', setup);
  </script>
</body>
</html>
